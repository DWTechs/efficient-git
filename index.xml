<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Use Git without hassle on Efficient-git</title><link>https://dwtechs.github.io/efficient-git/</link><description>Recent content in Use Git without hassle on Efficient-git</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><atom:link href="https://dwtechs.github.io/efficient-git/index.xml" rel="self" type="application/rss+xml"/><item><title/><link>https://dwtechs.github.io/efficient-git/conventional-commit/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/conventional-commit/</guid><description>Following those rules to write your commit messages will bring great advantages to a project :
Automatic CHANGELOGs capability. Automatic semantic version bump (based on the types of commits landed). Communicate the nature of changes to teammates, the public, and other stakeholders. Trigger build and publish processes. Make it easier for people to contribute to the project, by allowing them to explore a more structured commit history. The message is structured as follows:</description></item><item><title/><link>https://dwtechs.github.io/efficient-git/gitflow/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/gitflow/</guid><description>Gitflow is the most used Git branching model that involves the use of feature branches and multiple primary branches. Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch.</description></item><item><title/><link>https://dwtechs.github.io/efficient-git/merge/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/merge/</guid><description>Join two or more development histories together.
Description Incorporate changes since the time their histories diverged from your branch into the main branch. This command is actually used by git pull to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.
Pre-merge checks Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts (See also git-stash).</description></item><item><title>Alias</title><link>https://dwtechs.github.io/efficient-git/alias/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/alias/</guid><description>Aliases are shortcuts for your most-used or complex Git commands
Edit your git config file If it is located in your home folder and you are using nano, you can do so:
nano ~/.gitconfig Otherwise, pick the editor of your choice and the right location of the file.
If you don&amp;rsquo;t have this config file already, create it:
touch ~/.gitconfig Add the alias For example let&amp;rsquo;s add a useful shortcut for listing all your current branches with their last update time.</description></item><item><title>Branches</title><link>https://dwtechs.github.io/efficient-git/branch/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/branch/</guid><description>master: For production releases. develop: For next release development. Available branch prefixes for developers : feature: For new feature to develop. release: When release cycle is over. Features ready to ship are kept here. Freeing develop branch for next cycle. bugfix: For new bug to fix. hotfix: For production bug to fix ASAP on master branch. refactor: To improve or update code and structure. doc: To improve or update developer documentation.</description></item><item><title>Getting Started</title><link>https://dwtechs.github.io/efficient-git/overview/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/overview/</guid><description>Create a repo Let&amp;rsquo;s start manipulate Git by creating a Git repository.
In a new folder on your computer type :
git init This will create a hidden .git folder inside your current folder — this is the &amp;ldquo;repository&amp;rdquo; (or repo) where git stores all of its internal tracking data. Any changes you make to any files within the original folder will now be possible to track.</description></item><item><title>Save</title><link>https://dwtechs.github.io/efficient-git/save/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/save/</guid><description>Git is not meant to be used as a backup device. But let&amp;rsquo;s be pragmatic here as not every company has a proper way to backup developers work every day. As said before the core function of Git is to save checkpoints. And it has all the tools to recover from it very easily. Meaning that if use properly Git is a poweful backup application for developers.
to be continued</description></item><item><title>Semantic Versioning</title><link>https://dwtechs.github.io/efficient-git/semantic-versioning/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/semantic-versioning/</guid><description>Semantic versioning is not exactly a Git topic. But since you will need to bump the version of the application after each release and tag the master branch, you need to learn how to properly update it following the Semantic versioning principles.
Overview Given a version number MAJOR.MINOR.PATCH, increment the:
MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, PATCH version when you make backwards compatible bug fixes.</description></item><item><title>squash</title><link>https://dwtechs.github.io/efficient-git/squash/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/squash/</guid><description>What is Git Squashing Squashing in Git is the process of merging several commits into one.
Why would I want to squash my commits Often when we are working on a feature / bug fix / refactor etc, we may find ourselves making several interim commits over the duration of the change. Whilst we can push back to our main branch including all of these commits this creates noise in the commit history potentially making it harder to identify the actual commit we are interested in.</description></item><item><title>tag</title><link>https://dwtechs.github.io/efficient-git/tag/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/tag/</guid><description>Git has the ability to tag specific points in a repository’s history as being important. It is used to mark release points (v1.0, v2.0 and so on).
Listing Your Tags git tag This command lists the tags in alphabetical order; the order in which they are displayed has no real importance.
You can also search for tags that match a particular pattern. The Git source repo, for instance, contains more than 500 tags.</description></item><item><title>Teamwork</title><link>https://dwtechs.github.io/efficient-git/teamwork/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/teamwork/</guid><description>Submitting your changes After working on a new feature for the team you have your changes ready and tested on a branch. It is time to get them back onto the trunk as part of the “official” codebase.
Once you’ve tested your changes, you’ll do this via a pull request (PR) or a merge request (MR) — they’re the same thing, the term just depends on what software you’re using (e.</description></item><item><title>What is Git</title><link>https://dwtechs.github.io/efficient-git/intro/</link><pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate><guid>https://dwtechs.github.io/efficient-git/intro/</guid><description>Git is the most popular Version Control System.
It makes it easier to track changes to files in a project.
You can determine exactly what changed, who changed it, and why.
The core function of git is to save checkpoints (revisions) and share them with other people. Everything revolves around this concept. If you’ve ever created a checkpoint to something, you’ll be able to get back to it later as long as your .</description></item></channel></rss>