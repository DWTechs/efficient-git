[{"id":0,"href":"/efficient-git/conventional-commit/","title":"Conventional Commit","parent":"Use Git without hassle","content":"Following those rules to write your commit messages will bring great advantages to a project :\n Automatic CHANGELOGs capability. Automatic semantic version bump (based on the types of commits landed). Communicate the nature of changes to teammates, the public, and other stakeholders. Trigger build and publish processes. Make it easier for people to contribute to the project, by allowing them to explore a more structured commit history.  The message is structured as follows:\n\u0026lt;type\u0026gt;([optional scope]): \u0026lt;description\u0026gt; [optional body] [optional footer] Types     They are based on the Angular convention and must be one of the following:\n build: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm) ci: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs) docs: Documentation only changes feat: A new feature fix: A bug fix perf: A code change that improves performance refactor: A code change that neither fixes a bug nor adds a feature style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) test: Adding missing tests or correcting existing tests chore: Changes to the build process or auxiliary tools and libraries revert: Revert a previous commit. In this case it should begin with \u0026ldquo;revert:\u0026rdquo;, followed by the header of the reverted commit. In the body it should say: This reverts commit ., where the hash is the SHA of the commit being reverted.  Scope     The scope should be the name of the updated component.\nSubject     The subject contains a succinct description of the change:\n Use the imperative, present tense: \u0026ldquo;change\u0026rdquo; not \u0026ldquo;changed\u0026rdquo; nor \u0026ldquo;changes\u0026rdquo; Don\u0026rsquo;t capitalize the first letter No dot (.) at the end  Body     Just as in the subject, use the imperative, present tense: \u0026ldquo;change\u0026rdquo; not \u0026ldquo;changed\u0026rdquo; nor \u0026ldquo;changes\u0026rdquo;. The body should include the motivation for the change and contrast this with previous behavior.\nFooter     The footer should contain any information about Breaking Changes and is also the place to reference GitHub issues that this commit Closes.\nRules     A commit can contain the following structural elements :\n Fix: Patches a bug in your codebase (this correlates with PATCH in semantic versioning). Feat: Introduces a new feature to the codebase (this correlates with MINOR in semantic versioning). Additional types are not mandated by the conventional commits specification, and have no implicit effect in semantic versioning (unless they include a BREAKING CHANGE). BREAKING CHANGE: A commit that has a footer \u0026ldquo;BREAKING CHANGE:\u0026rdquo; introduces a breaking API change (correlating with MAJOR in semantic versioning). A BREAKING CHANGE can be part of commits of any type. footers other than \u0026ldquo;BREAKING CHANGE: \u0026rdquo; may be provided and follow a convention similar to git trailer format. A scope may be provided to a commit’s type, to provide additional contextual information and is contained within parenthesis (ex : feat(parser): add ability to parse arrays).  $ git commit -am \u0026#34;feat(lang): added polish language\u0026#34; $ git commit -am \u0026#39;feat(config): allow provided config object to extend other configs BREAKING CHANGE: extends key in config file is now used for extending other config files\u0026#39; Wizard     You can use npm and Commitizen to help you write conventional commit messages :\n$ npm run commit Automation      Husky : Prevents bad git commit, git push with git hooks. It will stop you if your commit message is not valid. Commitizen : Launch commitizen Wizard to commit your work. It will guide you to write good conventional commits easily.  "},{"id":1,"href":"/efficient-git/gitflow/","title":"Gitflow","parent":"Use Git without hassle","content":"Gitflow is the most used Git branching model that involves the use of feature branches and multiple primary branches. Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.\nGitflow can be used for projects that have a scheduled release cycle and for the DevOps best practice of continuous delivery. This workflow doesn’t add any new concepts or commands beyond what ahs been already discussed. In essence Gitflow assigns very specific roles to different branches and defines how and when they should interact. It uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.\nSummary     The overall flow is as follow :\n A develop branch is created from master. A release branch is created from develop. Feature, Doc, Test and Build branches are created from develop. When a feature is complete it is merged into the develop branch. When the release branch is done it is merged into develop then master on release date. If an issue in master is detected a hotfix branch is created from master. Once the hotfix is complete it is merged to both master and develop.  Here is a Gitflow chart to summarize the method :\n"},{"id":2,"href":"/efficient-git/merge/","title":"Merge","parent":"Use Git without hassle","content":"Join two or more development histories together.\nDescription     Incorporate changes since the time their histories diverged from your branch into the main branch. This command is actually used by git pull to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.\nPre-merge checks     Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts (See also git-stash).\nGit pull and git merge will stop without doing anything when local uncommitted changes overlap with files that git pull/git merge may need to update.\nIf all named commits are already ancestors of HEAD, git merge will exit early with the message \u0026ldquo;Already up to date.\u0026rdquo;\nHow to resolve conflicts     After seeing a conflict, you can do 2 things:\nDecide not to merge. If you tried a merge which resulted in complex conflicts and want to start over, you can recover with git merge \u0026ndash;abort.\nResolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit or git merge \u0026ndash;continue to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling git commit.\nYou can work through the conflict by looking at the diffs.\nGit diff will show a three-way diff, highlighting changes from both the HEAD and MERGE_HEAD versions.\nYou can learn more about resolving conflict in the Teamwork page\nHow to merge     Always start by merging from the main branch to the child branch.\nGet your branch up to date     During the development of a feature you can spend several days working on your branch created from develop. Everyday your colleagues will push their own work into develop, making your branch late by several commits. It is important to keep your branch up to date by merging develop into your branch regularly.\nOnce your branch is ready do the following :\ngit checkout develop git pull git checkout \u0026lt;working-branch-name\u0026gt; git merge --no-ff develop Fix conflicts if needed into your IDE\ngit merge --continue Your branch is now up to date. If the application runs properly you can safely keep working on your branch\nmerge into develop     You need to merge your working branch manually into \u0026ldquo;develop\u0026rdquo;. You don\u0026rsquo;t. Only tech leads are allowed to merge directly into develop. Please refer to \u0026ldquo;merge requests\u0026rdquo;\nLearn more about merge request   Tech lead will do the following :\nStep 1 : Start by merging develop into your working branch like this :     git checkout develop git pull git checkout \u0026lt;working-branch-name\u0026gt; git merge --no-ff develop Fix conflicts if needed into your IDE\ngit merge --continue git push Step 2 : Test your updated branch     If the application runs properly you can safely merge your branch into develop knowing there will be no conflicts anymore\nStep 3 : Merge your branch into develop     Make sure you are still up to date. If not repeat step 1:\ngit checkout develop git pull git merge --no-ff \u0026lt;working-branch-name\u0026gt; git push merge release into master     This is the end of the sprint. Release branch is going to be released to the client.\nAgain, Only tech leads are allowed to merge into develop.\nStep 1 : Start by merging master into develop like this :     git checkout master git pull git checkout develop git merge --no-ff master Fix conflicts if needed into your IDE\ngit merge --continue git push Step 2 : Test your updated release branch     If the application runs properly you can safely merge release into master knowing there will be no conflicts anymore\nStep 3 : Merge release into master     git checkout master git merge --no-ff develop git push At this point you can tag master xith the updated version number.\nLearn more about tagging   Repeat the process to push release into develop.\nYou can also use Gitlab graphics interface to merge while keeping the same order.\n"},{"id":3,"href":"/efficient-git/alias/","title":"Alias","parent":"Use Git without hassle","content":"Aliases are shortcuts for your most-used or complex Git commands\nEdit your git config file     If it is located in your home folder and you are using nano, you can do so:\nnano ~/.gitconfig Otherwise, pick the editor of your choice and the right location of the file.\nIf you don\u0026rsquo;t have this config file already, create it:\ntouch ~/.gitconfig Add the alias     For example let\u0026rsquo;s add a useful shortcut for listing all your current branches with their last update time.\nAdd the following lines to the config file (if you already have an \u0026ldquo;[alias]\u0026rdquo; section, just add the alias):\n[alias] wip= for-each-ref --sort=\u0026#39;authordate:iso8601\u0026#39; --format=\u0026#39; %(color:green)%(authordate:relative)%09%(color:white)%(refname:short)\u0026#39; refs/headsHow to use it     All you have to do now is typing git wip in your terminal.\ngit wip More useful aliases     s= status -sb a= add c= commit -m pl= pull ph= push d= diff md= merge --no-ff develop l= log --all --decorate --oneline --graph last= log -1 HEAD --stat conf= config --global -l Now you can commit faster :\ngit c \u0026#34;\u0026lt;conventional commit message\u0026gt;\u0026#34; or stage all files to commit :\ngit a . "},{"id":4,"href":"/efficient-git/branch/","title":"Branches","parent":"Use Git without hassle","content":" master: For production releases. develop: For next release development. Available branch prefixes for developers :  feature: For new feature to develop. release: When release cycle is over. Features ready to ship are kept here. Freeing develop branch for next cycle. bugfix: For new bug to fix. hotfix: For production bug to fix ASAP on master branch. refactor: To improve or update code and structure. doc: To improve or update developer documentation. test: To add or update unit tests or E2E tests. build: To improve the workflow of the project.    Feature branch     From : develop\nEach new feature should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen a feature is complete and tested, it gets merged back into develop. Features never interact directly with master.\nWhen a feature is way behind develop because of a long development process, merge develop into the feature branch to stay tuned.\ngit checkout develop git checkout -b feature/csv-export Release branch     From : develop\nOnce develop has acquired enough features for a release or a predetermined release date is approaching, you fork a release branch off of develop.\nCreating this branch starts the next release cycle, so no new features can be added after this point, only bug fixes, documentation generation, and other release-oriented tasks should go in this branch.\nOnce it\u0026rsquo;s ready to ship, the release branch gets merged into master and tagged with a version number. In addition, it should be merged back into develop, which may have progressed since the release was initiated.\nUsing a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development.\ngit checkout develop git checkout -b release/0.1.0 Bugfix branch     From : develop\nEach new bug should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen a bugfux is complete and tested, it gets merged back into develop. Bugfixes never interact directly with master.\ngit checkout develop git checkout -b bugfix/#456/export-button-color Hotfix branch     From : master\nUsed to quickly patch production releases.\nThis is the only branch that should fork directly off of master. As soon as the fix is complete, it should be merged into both master and develop (or the current release branch), and master should be tagged with an updated version number.\nHaving a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle.\ngit checkout master git checkout -b hotfix/#344/wrong-email-regex Refactor branch     From : develop\nUseful technical debt reduction, ESlint/SonarQube fix,\nEach refactor should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen refactor is complete and tested, it gets merged back into develop. Tests never interact directly with master.\ngit checkout develop git checkout -b refactor/export-csv-class Doc branch     From : develop\nEach documentation update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nDoc branch is only for developer documentation in order to improve collabortation in the team. User documentation update has to be developed in a feature branch.\nWhen documentation is complete, it gets merged back into develop. Documentations never interact directly with master.\ngit checkout develop git checkout -b doc/husky-pre-commit Test branch     From : develop\nEach test update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen test is complete, it gets merged back into develop. Tests never interact directly with master.\ngit checkout develop git checkout -b test/csv-export Build branch     From : develop\nEach build update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen build is complete and tested, it gets merged back into develop. Builds never interact directly with master.\ngit checkout develop git checkout -b build/gitbranchvalidator "},{"id":5,"href":"/efficient-git/overview/","title":"Getting Started","parent":"Use Git without hassle","content":"Create a repo     Let\u0026rsquo;s start manipulate Git by creating a Git repository.\nIn a new folder on your computer type :\ngit init This will create a hidden .git folder inside your current folder — this is the \u0026ldquo;repository\u0026rdquo; (or repo) where git stores all of its internal tracking data. Any changes you make to any files within the original folder will now be possible to track.\nThe original folder is now referred to as your working directory, as opposed to the repository (the .git folder) that tracks your changes. You work in the working directory. Simple!\nClone an existing repo     git clone https://github.com/xxx/xxxx.git This will download a .git repository from the internet (GitHub) to your computer and extract the latest snapshot of the repo (all the files) to your working directory. By default it will all be saved in a folder with the same name as the repo.\nThe URL you specify here is called the remote origin (the place where the files were originally downloaded from). This term will be used later on.\nView the status of your project     git status This will print some basic information, such as which files have recently been modified.\nYou should check your status anytime you’re confused. Git will print additional information depending on what’s currently going on in order to help you out.\nCreate a new branch     git branch \u0026lt;new-branch-name\u0026gt; You can think of this like creating a local “checkpoint” (technically called a reference) and giving it a name. It’s similar to doing File \u0026gt; Save as… in a text editor; the new branch that gets created is a reference to the current state of your repo. The branch name can then be used in various other commands as you’ll soon see.\nCommits are also checkpoints called a revision. The name will be a random-looking hash of numbers and letters such as e093542. This hash can then be used in various other commands just like branch names.\nWhen working on a project, every time you start a new feature or bug fix, you create a new branch from develop, release or master/main. Depending on the work you have to do and the moment in the sprint.\nFor more info about creating branches please refer to Gitflow/branch.\nCheck out a branch     git checkout \u0026lt;existing-branch-name\u0026gt; You can think of this like “resuming” from an existing checkpoint. All your files will be reset to whatever state they were in on that particular branch.\nKeep in mind that any changes in your working directory will be kept around. Preventing you to switch branche. See git stash if you’re interested in a simple way to avoid unwanted commits.\nYou can use the -b flag as a shortcut if you want to create the new branch while check it out all in one step. This is quite common:\ngit checkout -b \u0026lt;new-branch-name\u0026gt; View the differences between checkpoints:\ngit diff \u0026lt;branch-name\u0026gt; \u0026lt;other-branch-name\u0026gt; After editing some files, you can simply type git diff to view a list of the changes you’ve made. This is a good way to double-check your work before committing it.\nFor each group of changes, you’ll see what the file used to look like (prefixed with - and colored red), followed by what it looks like now (prefixed with + and colored green).\nSee further down for more advanced examples of this command.\nStage your changes     git add \u0026lt;files\u0026gt; After editing some files, this command will mark any changes you’ve made as “staged” (or “ready to be committed”).\nIf you then go and make more changes, those new changes will not automatically be staged, even if you’ve changed the same files as before. This is useful for controlling exactly what you commit, but also a major source of confusion for newcomers.\nIf you’re ever unsure, just type git status again to see what’s going on. You’ll see “Changes to be committed:” followed by file names in green. Below that you’ll see “Changes not staged for commit:” followed by file names in red. These are not yet staged.\nAs a shortcut, you can use wildcards just like with any other terminal command. For example:\ngit add README.md app/*.txt This will add the file README.md, as well as every file in the app folder that ends in .txt.\nYou can also add everything that’s changed like this :\ngit add --all Commit your staged changes     git commit This will open your default command-line text editor and ask you to type in a commit message. As soon as you save and quit, your commit will be saved locally.\nThe commit message is important to help other people understand what was changed and why you changed it. There’s a brief guide here explaining how to write useful commit messages.\nYou can use the -m flag as a shortcut to write a message. For example:\ngit commit -m “Add a new feature” Push your branch on the server     git push This will upload your branch to the remote named origin (remember, that’s the URL defined initially during clone).\nAfter a successful push, your teammates will then be able to pull your branch to view your commits (see git pull below).\nFetch the latest info about a repo     git fetch This will download the latest info about the repo from origin (such as all the different branches stored on GitHub).\nIt doesn’t change any of your local files — just updates the tracking data stored in the .git folder.\nMerge in changes from somebody else     git merge \u0026lt;other-branch-name\u0026gt; This will take all commits that exist on the other-branch-name branch and integrate them into your own current branch.\nThis uses whatever branch data is stored locally, so make sure you’ve run git pull first to download the latest info.\nYou can use the pull command to both fetch and merge all in one step.\nFor a deeper understanding of how merging works and how conflicts are resolved see the merge docs.\n"},{"id":6,"href":"/efficient-git/save/","title":"Save","parent":"Use Git without hassle","content":"Git is not meant to be used as a backup device. But let\u0026rsquo;s be pragmatic here as not every company has a proper way to backup developers work every day. As said before the core function of Git is to save checkpoints. And it has all the tools to recover from it very easily. Meaning that if use properly Git is a poweful backup application for developers.\nto be continued     "},{"id":7,"href":"/efficient-git/semantic-versioning/","title":"Semantic Versioning","parent":"Use Git without hassle","content":"Given a version number MAJOR.MINOR.PATCH, increment the:\n MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, PATCH version when you make backwards compatible bug fixes.  Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\nIntroduction     The bigger a system grows and the more packages integrated into a software, the more we need a solid versioning process.\nIn systems with many dependencies, releasing new package versions needs to be carefully handled.\nTo prevent any version issue we use a global set of rules and requirements that dictate how version numbers are assigned and incremented.\nConsider a version format of X.Y.Z (Major.Minor.Patch).\n Bug fixes not affecting the application increment the patch version Backwards compatible application additions/changes increment the minor version Backwards incompatible application changes increment the major version  Under this scheme, version numbers and the way they change convey meaning about the underlying code and what has been modified from one version to the next.\nSemantic Versioning Specification (SemVer)     A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers, and MUST NOT contain leading zeroes.\n X is the major version Y is the minor version Z is the patch version. Each element MUST increase numerically. For instance: 1.9.0 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0.  Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\nHistory       Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The application SHOULD NOT be considered stable.\n  Version 1.0.0 defines the first release in production. The way in which the version number is incremented after this release is dependent on the application and how it changes.\n  Patch version Z (x.y.Z | x \u0026gt; 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.\n  Minor version Y (x.Y.z | x \u0026gt; 0) MUST be incremented if new, backwards compatible functionality is introduced to the application. It MUST be incremented if any application functionality is marked as deprecated. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented.\n  Major version X (X.y.z | X \u0026gt; 0) MUST be incremented if any backwards incompatible changes are introduced to the application. It MAY also include minor and patch level changes. Patch and minor version MUST be reset to 0 when major version is incremented.\n  A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1.\n  Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining version precedence. Thus two versions that differ only in the build metadata, have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\n  precedence     Precedence refers to how versions are compared to each other when ordered.\nIt MUST be calculated by separating the version into major, minor, patch and pre-release identifiers in that order (Build metadata does not figure into precedence).\nIt is determined by the first difference when comparing each of these identifiers from left to right as follows: Major, minor, and patch versions are always compared numerically.\nExample: 1.0.0 \u0026lt; 2.0.0 \u0026lt; 2.1.0 \u0026lt; 2.1.1.\nWhen major, minor, and patch are equal, a pre-release version has lower precedence than a normal version:\nExample: 1.0.0-alpha \u0026lt; 1.0.0\nPrecedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing each dot separated identifier from left to right until a difference is found as follows:\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers with letters or hyphens are compared lexically in ASCII sort order.\nNumeric identifiers always have lower precedence than non-numeric identifiers.\nA larger set of pre-release fields has a higher precedence than a smaller set, if all of the preceding identifiers are equal.\nExample:     1.0.0-alpha \u0026lt; 1.0.0-alpha.1 \u0026lt; 1.0.0-alpha.beta \u0026lt; 1.0.0-beta \u0026lt; 1.0.0-beta.2 \u0026lt; 1.0.0-beta.11 \u0026lt; 1.0.0-rc.1 \u0026lt; 1.0.0.\nInitial phase     Start your initial development release at 0.1.0 and then increment the minor version for each subsequent release.\nWhen to release 1.0.0     If your software is being used in production, it should probably already be 1.0.0. If you have a stable application on which users have come to depend, you should be 1.0.0. If you’re worrying a lot about backwards compatibility, you should probably already be 1.0.0. If you’re changing the application every day you should either still be in version 0.y.z or on a separate development branch working on the next major version.\nBump to a major version.     This is a question of responsible development and foresight. Incompatible changes should not be introduced lightly to software that has a lot of dependent code. The cost that must be incurred to upgrade can be significant. Having to bump major versions to release incompatible changes means you’ll think through the impact of your changes, and evaluate the cost/benefit ratio involved.\nReleasing a backwards incompatibility by mistake     As soon as you realize that you’ve broken the Semantic Versioning spec, fix the problem and release a new minor version that corrects the problem and restores backwards compatibility. Even under this circumstance, it is unacceptable to modify versioned releases. If it’s appropriate, document the offending version and inform your users of the problem so that they are aware of the offending version.\nUpdating application dependencies without changing the application     That would be considered compatible since it does not affect the application. Software that explicitly depends on the same dependencies as your package should have their own dependency specifications and the author will notice any conflicts. Determining whether the change is a patch level or minor level modification depends on whether you updated your dependencies in order to fix a bug or introduce new functionality. In which case it’s a minor level increment.\nAltering the aplication     (i.e. the code incorrectly introduces a major breaking change in a patch release)\nUse your best judgment. If you have a huge audience that will be drastically impacted by changing the behavior back to what the public API intended, then it may be best to perform a major version release, even though the fix could strictly be considered a patch release. Remember, Semantic Versioning is all about conveying meaning by how the version number changes. If these changes are important to your users, use the version number to inform them.\nHandling deprecating functionality     Deprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API.\nSize limit on the version string     Use good judgment. A 255 character version string is overkill and unreadable.\nUsing v     “v1.2.3” is not a semantic version. However, prefixing a semantic version with a “v” is a common way (in English) to indicate it is a version number. Abbreviating “version” as “v” is often seen with version control. Example: git tag v1.2.3 -m \u0026ldquo;Release version 1.2.3\u0026rdquo;, in which case “v1.2.3” is a tag name and the semantic version is “1.2.3”.\n"},{"id":8,"href":"/efficient-git/squash/","title":"squash","parent":"Use Git without hassle","content":"What is Git Squashing     Squashing in Git is the process of merging several commits into one.\nWhy would I want to squash my commits     Often when we are working on a feature / bug fix / refactor etc, we may find ourselves making several interim commits over the duration of the change. Whilst we can push back to our main branch including all of these commits this creates noise in the commit history potentially making it harder to identify the actual commit we are interested in.\nHow do I Squash my commits     Git does not have a specific command to squash commits instead we make use of existing git commands to achieve a squash.\nrebase     Using a hypothetical example the first step to squashing our commits is to issue a git log\nas in\ngit log this will show the commit history, we can narrow this down to the commits we have made by using the \u0026ndash;committer followed by the persons name e.g.\ngit log --committer \u0026lt;username\u0026gt; or with a date range\ngit log --since 2022-04-21 In the above example we see 5 commits which are displayed in sequential order starting with the most recent. These commits contain various work in progress steps which have no real meaning in the context of our overall project, i.e. we are only interested in the final commit which is adding the new feature. Before we commit this branch back to origin we would like to get rid of all these interim commits and present one single clean commit representing the new feature we have added. As an added bonus this makes us look like a genius developer who built the feature at the first attempt.\nTo do this we can issue the git rebase command\ngit rebase -i \u0026lt;branch\u0026gt; Where n is the number of commits from and including the current head we want include in the rebase. (current head = 1)\nThe -i switch says rebase using interactive mode, which gives us control over which commits to squash.\nWe need to tell git which branch we are rebasing to, in the example below we will rebase back to the develop branch:\ngit rebase -i develop On issuing the command a \u0026ldquo;vi\u0026rdquo; editor will launch and show us the list of our commits with a command in front of each:\nWe can now choose which commits to keep (pick) and which commits to squash, with the exception of the first commit which we have to keep, as we need one commit to squash everything to.\nWe can now edit the text and choose which commits to keep aside from the first and which to squash.\nIn the example above we have chosen to squash the last four commits, and used the reword \u0026ldquo;r\u0026rdquo; command on the first commit to change the commit message to something more meaningful for our commit history, whilst retaining the actual commit.\nOnce we have made the selection we can save and exit the editor \u0026lt;:wq\u0026gt;.\nGit will reopen the editor again this time showing the final commit message. We should check this and remove any content we do not want in our final commit, sometimes we will see the history of commit messages, these can be removed.\nSave and quit the editor, git will now perform the rebase and once complete if we issue the git log command again our branch should only have the one commit:\nAt this point we can now push our branch back to our branch in our case \u0026ldquo;feature/amazing-feature\u0026rdquo; and raise a pull request- to merge into develop.\ngit push origin -u feature/amazing-feature Note: rebasing should only be done on your local branch and never against the remote branch unless you truly understand what you are doing.  Aside from rebasing to a branch we can also rebase to the current HEAD using\ngit rebase -i HEAD~\u0026lt;n\u0026gt; This allows us to perform a rebase at any stage allowing us to keep our local commit tree clean, but should be used with caution as we will not be able to revert back to a previous commit if it has been squashed.\n"},{"id":9,"href":"/efficient-git/tag/","title":"tag","parent":"Use Git without hassle","content":"Git has the ability to tag specific points in a repository’s history as being important. It is used to mark release points (v1.0, v2.0 and so on).\nListing Your Tags     git tag This command lists the tags in alphabetical order; the order in which they are displayed has no real importance.\nYou can also search for tags that match a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you’re interested only in looking at the 1.8.5 series, you can run this:\ngit tag -l \u0026#34;v1.8.5*\u0026#34; Create annotated Tags     You can use Github or Gitlab graphics interface to create a tag.\nAnnotated tags are stored as full objects in the Git database. They’re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).\ngit tag -a v1.4 -m \u0026#34;my version 1.4 is cool\u0026#34; You can see the tag data along with the commit that was tagged by using the git show command:\ngit show v1.4 Checking out     If you want to view the versions of files a tag is pointing to, you can do a git checkout of that tag, although this puts your repository in “detached HEAD” state, which has some ill side effects.\ngit checkout v2.0.0 Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\nRelease a new version of master     In the Gitflow process you want to tag master/main branch anytime you merge something into it.\nSo when release branch or a hotfix branch is merged into master, tagging master should be part of the process.\nYou can read the Semantic versioning page  to learn mor about how to tag the branch properly using the version number.\n"},{"id":10,"href":"/efficient-git/tags/","title":"Tags","parent":"Use Git without hassle","content":""},{"id":11,"href":"/efficient-git/teamwork/","title":"Teamwork","parent":"Use Git without hassle","content":"Submitting your changes     After working on a new feature for the team you have your changes ready and tested on a branch. It is time to get them back onto the trunk as part of the “official” codebase.\nOnce you’ve tested your changes, you’ll do this via a pull request (PR) or a merge request (MR) — they’re the same thing, the term just depends on what software you’re using (e.g. GitHub/Bitbucket/GitLab). You’re requesting that your changes be pulled in and merged.\nA merge request is done via the application used in the project : Github or Gitlab\nYour team will be happy to receive new PRs, even if the code needs a bit of work before being accepted. PRs are an important part of the open-source ecosystem.\nThe main thing to remember is to include a clear explanation of why you’re making the changes in order to give context.\nDiscussing and revising     Once you submit your PR, someone else on the team will need to look it over and leave feedback. They can ask questions and comment on specific lines of code, or they can give more general feedback about your changes. In some cases they may push their own changes directly to your branch, but usually they’ll ask you to make the changes yourself.\nIf you want to make changes based on the feedback, simply add more commits to your existing branch and push it to origin again. The PR will update automatically to reflect your changes.\nKeeping up to date     If some time goes by before your PR is accepted, it might get “stale”, meaning it’s based on an older version of the trunk. Your changes may have worked a week ago, but there’s no guarantee that they still work alongside other, more recent changes to the trunk.\nTo get up to date, you can “merge in” the changes using git merge develop/release. This will apply any new changes from the trunk on top of your work.\nYou are effectively just moving your branch up to the top of the trunk to stay up to date with the latest code.\nSome people may prefer \u0026ldquo;rebase\u0026rdquo; method; it is safer and easier to merge.\nDealing with conflicts     When merging, you will occasionally run into conflicts. This means you changed a line of code that someone else also changed, and git doesn’t know which version to keep.\nWhen this happens the output from git has weird \u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; ======= \u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; symbols.\nIn essence, you just need to remove those weird symbols and manually combine the code in between them.\nFor example, the line:\nprint \u0026ldquo;Hello\u0026rdquo; Might be changed on two separate branches, leading to the conflict:\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; print \u0026#34;Hello, world\u0026#34; ======= print \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; Which, when resolved, might become:\nprint \u0026#34;Hello, world!\u0026#34; After manually merging the conflicting lines together — keeping both the “world” and the “!”, which had each been added separately.\nAccepting your changes     Once all of the PR comments have been addressed and any conflicts have been resolved, your branch is ready to be merged!\nAn administrator of the codebase can accept the PR by merging your branch into the trunk — simply by pressing a button on GitHub/Gitliab — thus making your changes official.\nSquash merge     Squash merging is a merge option that allows you to condense the Git history of topic branches when you complete a pull request. Instead of each commit on the topic branch being added to the history of the default branch, a squash merge adds all the file changes to a single new commit on the default branch.\nWhen you merge using Gitlab or Github there is a checkbox to squash all the commits into one. It is highly recommanded to use it in order to keep a clean history on the default branch.\nA simple way to think about this is that squash merge gives you just the file changes, and a regular merge gives you the file changes and the commit history.\nWhen squash merging, it\u0026rsquo;s a good practice to delete the source branch. Deleting the source branch prevents confusion as the topic branch itself doesn\u0026rsquo;t have a commit merging it into the default branch.\n"},{"id":12,"href":"/efficient-git/","title":"Use Git without hassle","parent":"","content":"Understanding how to use Git will give a major boost to your daily work. A very useful tool indeed; And like every tool, it has been created mostly to make you gain time.\nBut if you and/or your team are not using it properly, Git can be a massive waste of time and money.\nThis guide will teach you how to Git efficiently. The simple and most useful way. In order to make Git as effortless as possible in your daily work and focus on development of applications.\nGetting Started   "},{"id":13,"href":"/efficient-git/intro/","title":"What is Git","parent":"Use Git without hassle","content":"Git is the most popular Version Control System.\nIt makes it easier to track changes to files in a project.\nYou can determine exactly what changed, who changed it, and why.\nThe core function of git is to save checkpoints (revisions) and share them with other people. Everything revolves around this concept. If you’ve ever created a checkpoint to something, you’ll be able to get back to it later as long as your .git folder is intact.\nSo everything in git can be thought of as a checkpoint. Here’s a list of the types of checkpoint :\nHEAD \u0026lt;branch-name\u0026gt;, e.g. master \u0026lt;commit-hash\u0026gt;, e.g. e093542d01d11c917c316bfaffd6c4e5633aba58 (or e093542 for short) \u0026lt;tag-name\u0026gt;, e.g. v1.0.0 It is mandatory for coordinating work among multiple people on a project, and for tracking progress over time by saving “checkpoints”.\nStarting from the trunk     Git uses a lot of “tree” analogies. You can think of your main codebase as the trunk of a tree.\nEvery time you add more changes (aka commits), your tree grows taller, straight up. Even if you delete code, that’s still considered a change and causes the tree to grow. It’s like how the “undo” history in a text editor saves your keystrokes, including backspace.\nGit, by default, calls the trunk main or master. You can call it whatever you want; there’s nothing special about these words other than that it’s conventional.\nYou can travel up and down the trunk — equivalent to going forward and backward in time — by checking out specific “checkpoints” as described in the overview.\nBranching out     Most projects have a backlog of new features to add and bugs to fix. When you want to address one of these issues, one way would be to grow the tree taller and commit directly to the trunk (master). This works fine for small projects or projects where you’re the only person making changes, but what if multiple people are working at the same time? It’s too easy to get in each other’s way and end up with conflicting changes.\nThe solution is branching. Instead of committing to the trunk, you create your own personal branch (e.g. my-cool-feature instead of master) and work from there. Now you’re growing your branch taller instead of the trunk.\nLet\u0026rsquo;s say your branch started at commit T2 from \u0026ldquo;develop\u0026rdquo;. While you were working on your branch (commits B1 and B2), someone else worked directly on develop (commits T3 and T4). Those commits aren’t in your branch yet; your branch is out of date.\nYou can also see real life branch visualizations on GitHub, or by typing :\ngit log --all --decorate --oneline --graph "}]