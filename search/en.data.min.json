[{"id":0,"href":"/efficient-git/gitflow/branches/","title":"Branches","parent":"Gitflow","content":" master: For production releases. develop: For next release development. Available branch prefixes for developers :  feature: For new feature to develop. release: When release cycle is over. Features ready to ship are kept here. Freeing develop branch for next cycle. bugfix: For new bug to fix. hotfix: For production bug to fix ASAP on master branch. refactor: To improve or update code and structure. doc: To improve or update developer documentation. test: To add or update unit tests or E2E tests. build: To improve the workflow of the project.    Feature branch     From : develop\nEach new feature should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen a feature is complete and tested, it gets merged back into develop. Features never interact directly with master.\nWhen a feature is way behind develop because of a long development process, merge develop into the feature branch to stay tuned.\ngit checkout develop git checkout -b feature/csv-export Release branch     From : develop\nOnce develop has acquired enough features for a release or a predetermined release date is approaching, you fork a release branch off of develop.\nCreating this branch starts the next release cycle, so no new features can be added after this point, only bug fixes, documentation generation, and other release-oriented tasks should go in this branch.\nOnce it\u0026rsquo;s ready to ship, the release branch gets merged into master and tagged with a version number. In addition, it should be merged back into develop, which may have progressed since the release was initiated.\nUsing a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development.\ngit checkout develop git checkout -b release/0.1.0 Bugfix branch     From : develop\nEach new bug should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen a bugfux is complete and tested, it gets merged back into develop. Bugfixes never interact directly with master.\ngit checkout develop git checkout -b bugfix/#456/export-button-color Hotfix branch     From : master\nUsed to quickly patch production releases.\nThis is the only branch that should fork directly off of master. As soon as the fix is complete, it should be merged into both master and develop (or the current release branch), and master should be tagged with an updated version number.\nHaving a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle.\ngit checkout master git checkout -b hotfix/#344/wrong-email-regex Refactor branch     From : develop\nUseful technical debt reduction, ESlint/SonarQube fix,\nEach refactor should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen refactor is complete and tested, it gets merged back into develop. Tests never interact directly with master.\ngit checkout develop git checkout -b refactor/export-csv-class Doc branch     From : develop\nEach documentation update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nDoc branch is only for developer documentation in order to improve collabortation in the team. User documentation update has to be developed in a feature branch.\nWhen documentation is complete, it gets merged back into develop. Documentations never interact directly with master.\ngit checkout develop git checkout -b doc/husky-pre-commit Test branch     From : develop\nEach test update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen test is complete, it gets merged back into develop. Tests never interact directly with master.\ngit checkout develop git checkout -b test/csv-export Build branch     From : develop\nEach build update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen build is complete and tested, it gets merged back into develop. Builds never interact directly with master.\ngit checkout develop git checkout -b build/gitbranchvalidator "},{"id":1,"href":"/efficient-git/gitflow/conventional-commits/","title":"Conventional Commits","parent":"Gitflow","content":"Following those rules bring great advantages to a project :\n Automatic CHANGELOGs. Automatic semantic version bump (based on the types of commits landed). Communicate the nature of changes to teammates, the public, and other stakeholders. Trigger build and publish processes. Make it easier for people to contribute to the project, by allowing them to explore a more structured commit history.  The message is structured as follows:\n\u0026lt;type\u0026gt;([optional scope]): \u0026lt;description\u0026gt; [optional body] [optional footer] Types     They are based on the Angular convention and must be one of the following:\n build: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm) ci: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs) docs: Documentation only changes feat: A new feature fix: A bug fix perf: A code change that improves performance refactor: A code change that neither fixes a bug nor adds a feature style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) test: Adding missing tests or correcting existing tests chore: Changes to the build process or auxiliary tools and libraries revert: Revert a previous commit. In this case it should begin with \u0026ldquo;revert:\u0026rdquo;, followed by the header of the reverted commit. In the body it should say: This reverts commit ., where the hash is the SHA of the commit being reverted.  Scope     The scope should be the name of the updated component.\nSubject     The subject contains a succinct description of the change:\n Use the imperative, present tense: \u0026ldquo;change\u0026rdquo; not \u0026ldquo;changed\u0026rdquo; nor \u0026ldquo;changes\u0026rdquo; Don\u0026rsquo;t capitalize the first letter No dot (.) at the end  Body     Just as in the subject, use the imperative, present tense: \u0026ldquo;change\u0026rdquo; not \u0026ldquo;changed\u0026rdquo; nor \u0026ldquo;changes\u0026rdquo;. The body should include the motivation for the change and contrast this with previous behavior.\nFooter     The footer should contain any information about Breaking Changes and is also the place to reference GitHub issues that this commit Closes.\nRules     A commit can contain the following structural elements :\n Fix: Patches a bug in your codebase (this correlates with PATCH in semantic versioning). Feat: Introduces a new feature to the codebase (this correlates with MINOR in semantic versioning). Additional types are not mandated by the conventional commits specification, and have no implicit effect in semantic versioning (unless they include a BREAKING CHANGE). BREAKING CHANGE: A commit that has a footer \u0026ldquo;BREAKING CHANGE:\u0026rdquo; introduces a breaking API change (correlating with MAJOR in semantic versioning). A BREAKING CHANGE can be part of commits of any type. footers other than \u0026ldquo;BREAKING CHANGE: \u0026rdquo; may be provided and follow a convention similar to git trailer format. A scope may be provided to a commit’s type, to provide additional contextual information and is contained within parenthesis (ex : feat(parser): add ability to parse arrays).  $ git commit -am \u0026#34;feat(lang): added polish language\u0026#34; $ git commit -am \u0026#39;feat(config): allow provided config object to extend other configs BREAKING CHANGE: extends key in config file is now used for extending other config files\u0026#39; Wizard     You can use npm and Commitizen to help you write conventional commit messages :\n$ npm run commit Automation      Husky : Prevents bad git commit, git push with git hooks. It will stop you if your commit message is not valid. Commitizen : Launch commitizen Wizard to commit your work. It will guide you to write good conventional commits easily.  "},{"id":2,"href":"/efficient-git/teamwork/","title":"Teamwork","parent":"","content":"Starting from the trunk     Git uses a lot of “tree” analogies. You can think of your main codebase as the trunk of a tree.\nEvery time you add more changes (aka commits), your tree grows taller, straight up. Even if you delete code, that’s still considered a change and causes the tree to grow. It’s like how the “undo” history in a text editor saves your keystrokes, including backspace.\nGit, by default, calls the trunk master. You can call it whatever you want; there’s nothing special about the word master other than that it’s conventional.\nYou can travel up and down the trunk — equivalent to going forward and backward in time — by checking out specific “checkpoints” as described in the overview.\nBranching out     Most projects have a backlog of new features to add and bugs to fix. When you want to address one of these issues, one way would be to grow the tree taller and commit directly to the trunk (master). This works fine for small projects or projects where you’re the only person making changes, but what if multiple people are working at the same time? It’s too easy to get in each other’s way and end up with conflicting changes.\nThe solution is branching. Instead of committing to the trunk, you create your own personal branch (e.g. my-cool-feature instead of master) and work from there. Now you’re growing your branch taller instead of the trunk.\nLet\u0026rsquo;s say your branch started at commit T2 from \u0026ldquo;develop\u0026rdquo;. While you were working on your branch (commits B1 and B2), someone else worked directly on develop (commits T3 and T4). Those commits aren’t in your branch yet; your branch is out of date.\nYou can also see real life branch visualizations on GitHub, or by typing :\ngit log --all --decorate --oneline --graph in your terminal. Submitting your changes     Now you have your changes on a branch, but the eventual goal is to get them back onto the trunk as part of the “official” codebase.\nOnce you’ve tested your changes, you’ll need to share them with the team. Typically you’ll do this via a pull request (PR) or a merge request (MR) — they’re the same thing, the term just depends on what software you’re using (e.g. GitHub/Bitbucket/GitLab). You’re requesting that your changes be pulled in and merged.\nMost teams are happy to receive new PRs, even if the code needs a bit of work before being accepted. PRs are an important part of the open-source ecosystem.\nThe main thing to remember is to include a clear explanation of why you’re making the changes in order to give context.\nDiscussing and revising     Once you submit your PR, someone else on the team will need to look it over and leave feedback. They can ask questions and comment on specific lines of code, or they can give more general feedback about your changes. In some cases they may push their own changes directly to your branch, but usually they’ll ask you to make the changes yourself.\nIf you want to make changes based on the feedback, simply add more commits to your existing branch and push it to origin again. The PR will update automatically to reflect your changes.\nKeeping up to date     If some time goes by before your PR is accepted, it might get “stale”, meaning it’s based on an older version of the trunk (like in the tree shown earlier). Your changes may have worked a week ago, but there’s no guarantee that they still work alongside other, more recent changes to the trunk.\nTo get up to date, you have two options:\nYou can “merge in” the changes using git merge master. This will apply any new changes from the trunk on top of your work. You can “rebase on top of” the changes using git rebase master. This re-applies your work on top of any new changes on the trunk. In either case, your own changes will still be the same — you’re effectively just moving your branch up to the top of the trunk to stay up to date with the latest code.\nDifferent teams may prefer one method or the other; it’s safer and easier to merge.\nDealing with conflicts     When merging or rebasing, you’ll occasionally run into conflicts. This means you changed a line of code that someone else also changed, and git doesn’t know which version to keep.\nWhen this happens the output from git looks really nasty, with weird \u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; ======= \u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; symbols. Don’t worry! It looks strange, but with a bit of practice you’ll understand it.\nIn essence, you just need to remove those weird symbols and manually combine the code in between them.\nFor example, the line:\nprint \u0026ldquo;Hello\u0026rdquo; Might be changed on two separate branches, leading to the conflict:\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; print \u0026#34;Hello, world\u0026#34; ======= print \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; Which, when resolved, might become:\nprint \u0026#34;Hello, world!\u0026#34; After manually merging the conflicting lines together — keeping both the “world” and the “!”, which had each been added separately.\nAccepting your changes     Once all of the PR comments have been addressed and any conflicts have been resolved, your branch is ready to be merged!\nAn administrator of the codebase can accept the PR by merging your branch into the trunk — simply by pressing a button on GitHub — thus making your changes official.\n"},{"id":3,"href":"/efficient-git/merge/","title":"Merge","parent":"","content":"Join two or more development histories together.\nDescription     Incorporate changes from the named commits (since the time their histories diverged from the current branch) into the current branch. This command is used by git pull to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.\nPre-merge checks     Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts (See also git-stash).\nGit pull and git merge will stop without doing anything when local uncommitted changes overlap with files that git pull/git merge may need to update.\nTo avoid recording unrelated changes in the merge commit, git pull and git merge will also abort if there are any changes registered in the index relative to the HEAD commit. (Special narrow exceptions to this rule may exist depending on which merge strategy is in use, but generally, the index must match HEAD.)\nIf all named commits are already ancestors of HEAD, git merge will exit early with the message \u0026ldquo;Already up to date.\u0026rdquo;\nTrue merge     the branches to be merged must be tied together by a merge commit that has both of them as its parents.\nA merged version reconciling the changes from all branches to be merged is committed, and your HEAD, index, and working tree are updated to it. It is possible to have modifications in the working tree as long as they do not overlap; the update will preserve them.\nWhen it is not obvious how to reconcile the changes, the following happens:\n The HEAD pointer stays the same. The MERGE_HEAD ref is set to point to the other branch head. Paths that merged cleanly are updated both in the index file and in your working tree. For conflicting paths, the index file records up to three versions: stage 1 stores the version from the common ancestor, stage 2 from HEAD, and stage 3 from MERGE_HEAD (you can inspect the stages with git ls-files -u). The working tree files contain the result of the \u0026ldquo;merge\u0026rdquo; program; i.e. 3-way merge results with familiar conflict markers \u0026laquo;\u0026lt; === \u0026raquo;\u0026gt;.  No other changes are made. In particular, the local modifications you had before you started merge will stay the same and the index entries for them stay as they were, i.e. matching HEAD.\nIf you tried a merge which resulted in complex conflicts and want to start over, you can recover with git merge \u0026ndash;abort.\nHow to resolve conflicts     After seeing a conflict, you can do 2 things:\nDecide not to merge. The only clean-ups you need are to reset the index file to the HEAD commit. git merge \u0026ndash;abort can be used for this.\nResolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit or git merge \u0026ndash;continue to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling git commit.\nYou can work through the conflict by looking at the diffs.\nGit diff will show a three-way diff, highlighting changes from both the HEAD and MERGE_HEAD versions.\nHow to merge     Always start by merging from the main branch to the child branch.\nExample 1     If you need to merge your working branch manually into \u0026ldquo;develop\u0026rdquo;.\nStep 1 : Start by merging develop into your working branch like this :     git checkout develop git pull git checkout \u0026lt;working-branch-name\u0026gt; git merge --no-ff develop Fix conflicts if needed into your IDE\ngit merge --continue git push Step 2 : Test your updated branch     If the application runs properly you can safely merge your branch into develop knowing there will be no conflicts anymore\nStep 3 : Merge your branch into develop     git checkout develop git pull Git pull makes sure you are still up to date. If not repeat step 1.\ngit merge --no-ff \u0026lt;working-branch-name\u0026gt; git push Example 2     Another example when merging develop into master This type of merge should be done by a lead dev only.\nStep 1 : Start by merging master into develop like this :     git checkout master git pull git checkout develop git merge --no-ff master Fix conflicts if needed into your IDE\ngit merge --continue git push Step 2 : Test your updated develop branch     If the application runs properly you can safely merge your branch into master knowing there will be no conflicts anymore\nStep 3 : Merge develop into master     git checkout master git pull Git pull makes sure you are still up to date. If not repeat step 1.\ngit merge --no-ff develop git push You can also use Gitlab graphics interface to merge while keeping the same order.\n"},{"id":4,"href":"/efficient-git/squash/","title":"Squash","parent":"","content":""},{"id":5,"href":"/efficient-git/tag/","title":"Tag","parent":"","content":"Git has the ability to tag specific points in a repository’s history as being important. It is used to mark release points (v1.0, v2.0 and so on).\nListing Your Tags     git tag This command lists the tags in alphabetical order; the order in which they are displayed has no real importance.\nYou can also search for tags that match a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you’re interested only in looking at the 1.8.5 series, you can run this:\ngit tag -l \u0026#34;v1.8.5*\u0026#34; Create annotated Tags     You can use Gitlab graphics interface to create a tag.\nAnnotated tags are stored as full objects in the Git database. They’re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG). It’s generally recommended that you create annotated tags so you can have all this information; but if you want a temporary tag or for some reason don’t want to keep the other information, lightweight tags are available too.\ngit tag -a v1.4 -m \u0026#34;my version 1.4 is cool\u0026#34; You can see the tag data along with the commit that was tagged by using the git show command:\ngit show v1.4 Checking out     If you want to view the versions of files a tag is pointing to, you can do a git checkout of that tag, although this puts your repository in “detached HEAD” state, which has some ill side effects.\ngit checkout v2.0.0 Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\n"},{"id":6,"href":"/efficient-git/semantic-versioning/","title":"Semantic Versioning","parent":"","content":"Given a version number MAJOR.MINOR.PATCH, increment the:\n MAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, PATCH version when you make backwards compatible bug fixes.  Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\nIntroduction     The bigger a system grows and the more packages integrated into a software, the more we need a solid versioning process.\nIn systems with many dependencies, releasing new package versions needs to be carefully handled.\nTo prevent any version issue we use a global set of rules and requirements that dictate how version numbers are assigned and incremented.\nConsider a version format of X.Y.Z (Major.Minor.Patch).\n Bug fixes not affecting the application increment the patch version Backwards compatible application additions/changes increment the minor version Backwards incompatible application changes increment the major version  Under this scheme, version numbers and the way they change convey meaning about the underlying code and what has been modified from one version to the next.\nSemantic Versioning Specification (SemVer)     A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers, and MUST NOT contain leading zeroes.\n X is the major version Y is the minor version Z is the patch version. Each element MUST increase numerically. For instance: 1.9.0 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0.  Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\nHistory       Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The application SHOULD NOT be considered stable.\n  Version 1.0.0 defines the first release in production. The way in which the version number is incremented after this release is dependent on the application and how it changes.\n  Patch version Z (x.y.Z | x \u0026gt; 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.\n  Minor version Y (x.Y.z | x \u0026gt; 0) MUST be incremented if new, backwards compatible functionality is introduced to the application. It MUST be incremented if any application functionality is marked as deprecated. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented.\n  Major version X (X.y.z | X \u0026gt; 0) MUST be incremented if any backwards incompatible changes are introduced to the application. It MAY also include minor and patch level changes. Patch and minor version MUST be reset to 0 when major version is incremented.\n  A pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1.\n  Build metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining version precedence. Thus two versions that differ only in the build metadata, have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\n  precedence     Precedence refers to how versions are compared to each other when ordered.\nIt MUST be calculated by separating the version into major, minor, patch and pre-release identifiers in that order (Build metadata does not figure into precedence).\nIt is determined by the first difference when comparing each of these identifiers from left to right as follows: Major, minor, and patch versions are always compared numerically.\nExample: 1.0.0 \u0026lt; 2.0.0 \u0026lt; 2.1.0 \u0026lt; 2.1.1.\nWhen major, minor, and patch are equal, a pre-release version has lower precedence than a normal version:\nExample: 1.0.0-alpha \u0026lt; 1.0.0\nPrecedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing each dot separated identifier from left to right until a difference is found as follows:\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers with letters or hyphens are compared lexically in ASCII sort order.\nNumeric identifiers always have lower precedence than non-numeric identifiers.\nA larger set of pre-release fields has a higher precedence than a smaller set, if all of the preceding identifiers are equal.\nExample: 1.0.0-alpha \u0026lt; 1.0.0-alpha.1 \u0026lt; 1.0.0-alpha.beta \u0026lt; 1.0.0-beta \u0026lt; 1.0.0-beta.2 \u0026lt; 1.0.0-beta.11 \u0026lt; 1.0.0-rc.1 \u0026lt; 1.0.0.\nExamples :     \u0026lt;valid semver\u0026gt; ::= \u0026lt;version core\u0026gt; | \u0026lt;version core\u0026gt; \u0026#34;-\u0026#34; \u0026lt;pre-release\u0026gt; | \u0026lt;version core\u0026gt; \u0026#34;+\u0026#34; \u0026lt;build\u0026gt; | \u0026lt;version core\u0026gt; \u0026#34;-\u0026#34; \u0026lt;pre-release\u0026gt; \u0026#34;+\u0026#34; \u0026lt;build\u0026gt; \u0026lt;version core\u0026gt; ::= \u0026lt;major\u0026gt; \u0026#34;.\u0026#34; \u0026lt;minor\u0026gt; \u0026#34;.\u0026#34; \u0026lt;patch\u0026gt; \u0026lt;major\u0026gt; ::= \u0026lt;numeric identifier\u0026gt; \u0026lt;minor\u0026gt; ::= \u0026lt;numeric identifier\u0026gt; \u0026lt;patch\u0026gt; ::= \u0026lt;numeric identifier\u0026gt; \u0026lt;pre-release\u0026gt; ::= \u0026lt;dot-separated pre-release identifiers\u0026gt; \u0026lt;dot-separated pre-release identifiers\u0026gt; ::= \u0026lt;pre-release identifier\u0026gt; | \u0026lt;pre-release identifier\u0026gt; \u0026#34;.\u0026#34; \u0026lt;dot-separated pre-release identifiers\u0026gt; \u0026lt;build\u0026gt; ::= \u0026lt;dot-separated build identifiers\u0026gt; \u0026lt;dot-separated build identifiers\u0026gt; ::= \u0026lt;build identifier\u0026gt; | \u0026lt;build identifier\u0026gt; \u0026#34;.\u0026#34; \u0026lt;dot-separated build identifiers\u0026gt; \u0026lt;pre-release identifier\u0026gt; ::= \u0026lt;alphanumeric identifier\u0026gt; | \u0026lt;numeric identifier\u0026gt; \u0026lt;build identifier\u0026gt; ::= \u0026lt;alphanumeric identifier\u0026gt; | \u0026lt;digits\u0026gt; \u0026lt;alphanumeric identifier\u0026gt; ::= \u0026lt;non-digit\u0026gt; | \u0026lt;non-digit\u0026gt; \u0026lt;identifier characters\u0026gt; | \u0026lt;identifier characters\u0026gt; \u0026lt;non-digit\u0026gt; | \u0026lt;identifier characters\u0026gt; \u0026lt;non-digit\u0026gt; \u0026lt;identifier characters\u0026gt; \u0026lt;numeric identifier\u0026gt; ::= \u0026#34;0\u0026#34; | \u0026lt;positive digit\u0026gt; | \u0026lt;positive digit\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;identifier characters\u0026gt; ::= \u0026lt;identifier character\u0026gt; | \u0026lt;identifier character\u0026gt; \u0026lt;identifier characters\u0026gt; \u0026lt;identifier character\u0026gt; ::= \u0026lt;digit\u0026gt; | \u0026lt;non-digit\u0026gt; \u0026lt;non-digit\u0026gt; ::= \u0026lt;letter\u0026gt; | \u0026#34;-\u0026#34; \u0026lt;digits\u0026gt; ::= \u0026lt;digit\u0026gt; | \u0026lt;digit\u0026gt; \u0026lt;digits\u0026gt; \u0026lt;digit\u0026gt; ::= \u0026#34;0\u0026#34; | \u0026lt;positive digit\u0026gt; \u0026lt;positive digit\u0026gt; ::= \u0026#34;1\u0026#34; | \u0026#34;2\u0026#34; | \u0026#34;3\u0026#34; | \u0026#34;4\u0026#34; | \u0026#34;5\u0026#34; | \u0026#34;6\u0026#34; | \u0026#34;7\u0026#34; | \u0026#34;8\u0026#34; | \u0026#34;9\u0026#34; \u0026lt;letter\u0026gt; ::= \u0026#34;A\u0026#34; | \u0026#34;B\u0026#34; | \u0026#34;C\u0026#34; | \u0026#34;D\u0026#34; | \u0026#34;E\u0026#34; | \u0026#34;F\u0026#34; | \u0026#34;G\u0026#34; | \u0026#34;H\u0026#34; | \u0026#34;I\u0026#34; | \u0026#34;J\u0026#34; | \u0026#34;K\u0026#34; | \u0026#34;L\u0026#34; | \u0026#34;M\u0026#34; | \u0026#34;N\u0026#34; | \u0026#34;O\u0026#34; | \u0026#34;P\u0026#34; | \u0026#34;Q\u0026#34; | \u0026#34;R\u0026#34; | \u0026#34;S\u0026#34; | \u0026#34;T\u0026#34; | \u0026#34;U\u0026#34; | \u0026#34;V\u0026#34; | \u0026#34;W\u0026#34; | \u0026#34;X\u0026#34; | \u0026#34;Y\u0026#34; | \u0026#34;Z\u0026#34; | \u0026#34;a\u0026#34; | \u0026#34;b\u0026#34; | \u0026#34;c\u0026#34; | \u0026#34;d\u0026#34; | \u0026#34;e\u0026#34; | \u0026#34;f\u0026#34; | \u0026#34;g\u0026#34; | \u0026#34;h\u0026#34; | \u0026#34;i\u0026#34; | \u0026#34;j\u0026#34; | \u0026#34;k\u0026#34; | \u0026#34;l\u0026#34; | \u0026#34;m\u0026#34; | \u0026#34;n\u0026#34; | \u0026#34;o\u0026#34; | \u0026#34;p\u0026#34; | \u0026#34;q\u0026#34; | \u0026#34;r\u0026#34; | \u0026#34;s\u0026#34; | \u0026#34;t\u0026#34; | \u0026#34;u\u0026#34; | \u0026#34;v\u0026#34; | \u0026#34;w\u0026#34; | \u0026#34;x\u0026#34; | \u0026#34;y\u0026#34; | \u0026#34;z\u0026#34; Initial phase     Start your initial development release at 0.1.0 and then increment the minor version for each subsequent release.\nWhen to release 1.0.0     If your software is being used in production, it should probably already be 1.0.0. If you have a stable application on which users have come to depend, you should be 1.0.0. If you’re worrying a lot about backwards compatibility, you should probably already be 1.0.0. If you’re changing the application every day you should either still be in version 0.y.z or on a separate development branch working on the next major version.\nBump to a major version.     This is a question of responsible development and foresight. Incompatible changes should not be introduced lightly to software that has a lot of dependent code. The cost that must be incurred to upgrade can be significant. Having to bump major versions to release incompatible changes means you’ll think through the impact of your changes, and evaluate the cost/benefit ratio involved.\nReleasing a backwards incompatibility by mistake     As soon as you realize that you’ve broken the Semantic Versioning spec, fix the problem and release a new minor version that corrects the problem and restores backwards compatibility. Even under this circumstance, it is unacceptable to modify versioned releases. If it’s appropriate, document the offending version and inform your users of the problem so that they are aware of the offending version.\nUpdating application dependencies without changing the application     That would be considered compatible since it does not affect the application. Software that explicitly depends on the same dependencies as your package should have their own dependency specifications and the author will notice any conflicts. Determining whether the change is a patch level or minor level modification depends on whether you updated your dependencies in order to fix a bug or introduce new functionality. In which case it’s a minor level increment.\nAltering the aplication     (i.e. the code incorrectly introduces a major breaking change in a patch release)\nUse your best judgment. If you have a huge audience that will be drastically impacted by changing the behavior back to what the public API intended, then it may be best to perform a major version release, even though the fix could strictly be considered a patch release. Remember, Semantic Versioning is all about conveying meaning by how the version number changes. If these changes are important to your users, use the version number to inform them.\nHandling deprecating functionality     Deprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API.\nSize limit on the version string     Use good judgment. A 255 character version string is overkill and unreadable.\nUsing v     “v1.2.3” is not a semantic version. However, prefixing a semantic version with a “v” is a common way (in English) to indicate it is a version number. Abbreviating “version” as “v” is often seen with version control. Example: git tag v1.2.3 -m \u0026ldquo;Release version 1.2.3\u0026rdquo;, in which case “v1.2.3” is a tag name and the semantic version is “1.2.3”.\n"},{"id":7,"href":"/efficient-git/","title":"","parent":"","content":"Git is the most popular Version Control System.\nIt makes it easier to track changes to files in a project.\nYou can determine exactly what changed, who changed it, and why.\nIt is mandatory for coordinating work among multiple people on a project, and for tracking progress over time by saving “checkpoints”.\nUnderstanding how to use it will give a major boost to your resume.\nGit can be a massive waste of time and money when your development team is not using it properly.\nLearn how to Git efficiently with your team with the help of this guide.\nGetting Started   "},{"id":8,"href":"/efficient-git/gitflow/","title":"Gitflow","parent":"","content":"Giflow is an alternative Git branching model that involves the use of feature branches and multiple primary branches. Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.\nGitflow can be used for projects that have a scheduled release cycle and for the DevOps best practice of continuous delivery. This workflow doesn’t add any new concepts or commands beyond what’s required for the Feature Branch Workflow. Instead, it assigns very specific roles to different branches and defines how and when they should interact. In addition to feature branches, it uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.\nSummary     The overall flow is as follow :\n A develop branch is created from master. A release branch is created from develop. Feature, Doc, Test and Build branches are created from develop. When a feature is complete it is merged into the develop branch. When the release branch is done it is merged into develop then master on release date. If an issue in master is detected a hotfix branch is created from master. Once the hotfix is complete it is merged to both develop and master.  "},{"id":9,"href":"/efficient-git/overview/","title":"Overview","parent":"","content":"Start a repo from scratch     In any existing folder on your computer type :\ngit init This will create a hidden .git folder inside your current folder — this is the \u0026ldquo;repository\u0026rdquo; (or repo) where git stores all of its internal tracking data. Any changes you make to any files within the original folder will now be possible to track.\nThe original folder is now referred to as your working directory, as opposed to the repository (the .git folder) that tracks your changes. You work in the working directory. Simple!\nClone an existing repo     git clone https://github.com/xxx/xxxx.git This will download a .git repository from the internet (GitHub) to your computer and extract the latest snapshot of the repo (all the files) to your working directory. By default it will all be saved in a folder with the same name as the repo.\nThe URL you specify here is called the remote origin (the place where the files were originally downloaded from). This term will be used later on.\nView the status of your project     git status This will print some basic information, such as which files have recently been modified.\nYou should check your status anytime you’re confused. Git will print additional information depending on what’s currently going on in order to help you out.\nCreate a new branch     git branch \u0026lt;new-branch-name\u0026gt; You can think of this like creating a local “checkpoint” (technically called a reference) and giving it a name. It’s similar to doing File \u0026gt; Save as… in a text editor; the new branch that gets created is a reference to the current state of your repo. The branch name can then be used in various other commands as you’ll soon see.\nSimilar to branching, more commonly you will save each checkpoint as you go along in the form of commits (see git commit below soon).\nCommits are a particular type of checkpoint called a revision. The name will be a random-looking hash of numbers and letters such as e093542. This hash can then be used in various other commands just like branch names.\nThat’s really the core function of git: To save checkpoints (revisions) and share them with other people. Everything revolves around this concept. If you’ve ever created a checkpoint to something, you’ll be able to get back to it later as long as your .git folder is intact.\nCheck out a branch     git checkout \u0026lt;existing-branch-name\u0026gt; You can think of this like “resuming” from an existing checkpoint. All your files will be reset to whatever state they were in on that particular branch.\nKeep in mind that any changes in your working directory will be kept around. See git stash if you’re interested in a simple way to avoid headaches.\nYou can use the -b flag as a shortcut to create a new branch and then check it out all in one step. This is quite common:\ngit checkout -b \u0026lt;new-branch-name\u0026gt; View the differences between checkpoints:\ngit diff \u0026lt;branch-name\u0026gt; \u0026lt;other-branch-name\u0026gt; After editing some files, you can simply type git diff to view a list of the changes you’ve made. This is a good way to double-check your work before committing it.\nFor each group of changes, you’ll see what the file used to look like (prefixed with - and colored red), followed by what it looks like now (prefixed with + and colored green).\nSee further down for more advanced examples of this command.\nStage your changes     git add \u0026lt;files\u0026gt; After editing some files, this command will mark any changes you’ve made as “staged” (or “ready to be committed”).\nIf you then go and make more changes, those new changes will not automatically be staged, even if you’ve changed the same files as before. This is useful for controlling exactly what you commit, but also a major source of confusion for newcomers.\nIf you’re ever unsure, just type git status again to see what’s going on. You’ll see “Changes to be committed:” followed by file names in green. Below that you’ll see “Changes not staged for commit:” followed by file names in red. These are not yet staged.\nAs a shortcut, you can use wildcards just like with any other terminal command. For example:\ngit add README.md app/*.txt This will add the file README.md, as well as every file in the app folder that ends in .txt. Typically you can just type git add \u0026ndash;all to add everything that’s changed.\nCommit your staged changes     git commit This will open your default command-line text editor and ask you to type in a commit message. As soon as you save and quit, your commit will be saved locally.\nThe commit message is important to help other people understand what was changed and why you changed it. There’s a brief guide here explaining how to write useful commit messages.\nYou can use the -m flag as a shortcut to write a message. For example:\ngit commit -m “Add a new feature” Push your branch on the server     git push origin \u0026lt;branch-name\u0026gt; This will upload your branch to the remote named origin (remember, that’s the URL defined initially during clone).\nAfter a successful push, your teammates will then be able to pull your branch to view your commits (see git pull below).\nAs a shortcut, you can type the word HEAD instead of branch-name to automatically use the branch you’re currently on. HEAD always refers to your latest checkpoint, that is, the latest commit on your current branch.\nAs mentioned earlier, everything in git can be thought of as a checkpoint. Here’s a list of the types of checkpoint you know about now (again, these are technically called “references” and “revisions”):\nHEAD \u0026lt;branch-name\u0026gt;, e.g. master \u0026lt;commit-hash\u0026gt;, e.g. e093542d01d11c917c316bfaffd6c4e5633aba58 (or e093542 for short) \u0026lt;tag-name\u0026gt;, e.g. v1.0.0 Fetch the latest info about a repo     git fetch This will download the latest info about the repo from origin (such as all the different branches stored on GitHub).\nIt doesn’t change any of your local files — just updates the tracking data stored in the .git folder.\nMerge in changes from somebody else     git merge \u0026lt;other-branch-name\u0026gt; This will take all commits that exist on the other-branch-name branch and integrate them into your own current branch.\nThis uses whatever branch data is stored locally, so make sure you’ve run git fetch first to download the latest info.\nFor example, if someone else adds a few commits to the master branch of origin, you can do the following to download their changes and update your own local master branch:\ngit checkout master # Make sure you\u0026#39;re on the right branch. git fetch # Download any new info from origin. git merge origin/master # Merge the \u0026#39;origin/master\u0026#39; branch into your current branch. The name origin/master here literally means the origin/master checkpoint on your computer. Git uses this notation to differentiate branches of the same name (e.g. master) located in different places (e.g. your own branches vs. origin\u0026rsquo;s branches).\nAs a shortcut, you can use the pull command to both fetch and merge all in one step. This is more common than merging manually like above:\ngit pull origin master Here we separate the words origin and master (without a slash like above). We don\u0026rsquo;t want to use the origin/master checkpoint on our own computer, because that\u0026rsquo;s stored offline and is probably out of date. We instead want to fetch directly from the master branch of the remote endpoint called origin.\nFor a deeper understanding of how merging works and how conflicts are resolved see the merge docs.\n"},{"id":10,"href":"/efficient-git/tags/","title":"Tags","parent":"","content":""}]