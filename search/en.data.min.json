[{"id":0,"href":"/efficient-git/merge/","title":"Merge","parent":"Efficient Git","content":"Join two or more development histories together.\nDescription Incorporate changes since the time their histories diverged from your branch into the main branch. This command is actually used by git pull to incorporate changes from another repository and can be used by hand to merge changes from one branch into another.\nPre-merge checks Before applying outside changes, you should get your own work in good shape and committed locally, so it will not be clobbered if there are conflicts (See also git-stash).\nGit pull and git merge will stop without doing anything when local uncommitted changes overlap with files that git pull/git merge may need to update.\nIf all named commits are already ancestors of HEAD, git merge will exit early with the message \u0026ldquo;Already up to date.\u0026rdquo;\nHow to resolve conflicts After seeing a conflict, you can do 2 things:\nDecide not to merge. If you tried a merge which resulted in complex conflicts and want to start over, you can recover with git merge \u0026ndash;abort.\nResolve the conflicts. Git will mark the conflicts in the working tree. Edit the files into shape and git add them to the index. Use git commit or git merge \u0026ndash;continue to seal the deal. The latter command checks whether there is a (interrupted) merge in progress before calling git commit.\nYou can work through the conflict by looking at the diffs.\nGit diff will show a three-way diff, highlighting changes from both the HEAD and MERGE_HEAD versions.\nYou can learn more about resolving conflict in the Teamwork page\nHow to merge Always start by merging from the main branch to the child branch.\nGet your branch up to date During the development of a feature you can spend several days working on your branch created from develop. Everyday your colleagues will push their own work into develop, making your branch late by several commits. It is important to keep your branch up to date by merging develop into your branch regularly.\nOnce your branch is ready do the following :\ngit checkout develop git pull git checkout \u0026lt;working-branch-name\u0026gt; git merge --no-ff develop Fix conflicts if needed into your IDE\ngit merge --continue Your branch is now up to date. If the application runs properly you can safely keep working on your branch\nmerge into develop You need to merge your working branch manually into \u0026ldquo;develop\u0026rdquo;. You don\u0026rsquo;t. Only tech leads are allowed to merge directly into develop. Please refer to \u0026ldquo;merge requests\u0026rdquo;\nLearn more about merge request Tech lead will do the following :\nStep 1 : Start by merging develop into your working branch like this : git checkout develop git pull git checkout \u0026lt;working-branch-name\u0026gt; git merge --no-ff develop Fix conflicts if needed into your IDE\ngit merge --continue git push Step 2 : Test your updated branch If the application runs properly you can safely merge your branch into develop knowing there will be no conflicts anymore\nStep 3 : Merge your branch into develop Make sure you are still up to date. If not repeat step 1:\ngit checkout develop git pull git merge --no-ff \u0026lt;working-branch-name\u0026gt; git push merge release into master This is the end of the sprint. Release branch is going to be released to the client.\nAgain, Only tech leads are allowed to merge into develop.\nStep 1 : Start by merging master into develop like this : git checkout master git pull git checkout develop git merge --no-ff master Fix conflicts if needed into your IDE\ngit merge --continue git push Step 2 : Test your updated release branch If the application runs properly you can safely merge release into master knowing there will be no conflicts anymore\nStep 3 : Merge release into master git checkout master git merge --no-ff develop git push At this point you can tag master xith the updated version number.\nLearn more about tagging Repeat the process to push release into develop.\nYou can also use Gitlab graphics interface to merge while keeping the same order.\n"},{"id":1,"href":"/efficient-git/alias/","title":"Alias","parent":"Efficient Git","content":"Aliases are shortcuts for your most-used or complex Git commands\nEdit your git config file If it is located in your home folder and you are using nano, you can do so:\nnano ~/.gitconfig Otherwise, pick the editor of your choice and the right location of the file.\nIf you don\u0026rsquo;t have this config file already, create it:\ntouch ~/.gitconfig Add the alias For example let\u0026rsquo;s add a useful shortcut for listing all your current branches with their last update time.\nAdd the following lines to the config file (if you already have an \u0026ldquo;[alias]\u0026rdquo; section, just add the alias):\n[alias] wip= for-each-ref --sort=\u0026#39;authordate:iso8601\u0026#39; --format=\u0026#39; %(color:green)%(authordate:relative)%09%(color:white)%(refname:short)\u0026#39; refs/heads How to use it git wip Which should show you something like this:\n11 days ago bugfix/undefined-recipe-title 10 days ago feature/edit-header-tags 6 days ago feature/new-app-icons 2 days ago test/authentication Other useful aliases s= status -sb a= add c= commit -m pl= pull ph= push d= diff md= merge --no-ff develop l= log --all --decorate --oneline --graph last= log -1 HEAD --stat conf= config --global -l Now you can commit like a pro :\ngit pl git s git a . git c \u0026#34;\u0026lt;conventional commit message\u0026gt;\u0026#34; git ph "},{"id":2,"href":"/efficient-git/branch/","title":"Branches","parent":"Efficient Git","content":" master: For production releases. develop: For next release development. Available branch prefixes for developers : feat: For new feature to develop. Or anything else which not fit into other prefixes below. release: When release cycle is over. Features ready to ship are kept here. Freeing develop branch for next cycle. fix: For new bug to fix or hotfix required on master branch. doc: To improve or update developer documentation. test: To add or update unit tests or E2E tests. Feature branch From : develop\nEach new feature should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen a feature is complete and tested, it gets merged back into develop. Features never interact directly with master.\nWhen a feature is way behind develop because of a long development process, merge develop into the feature branch to stay tuned.\ngit checkout develop git checkout -b feat/#245/csv-export Release branch From : develop\nOnce develop has acquired enough features for a release or a predetermined release date is approaching, you fork a release branch off of develop.\nCreating this branch starts the next release cycle, so no new features can be added after this point, only bug fixes, documentation generation, and other release-oriented tasks should go in this branch.\nOnce it\u0026rsquo;s ready to ship, the release branch gets merged into master and tagged with a version number. In addition, it should be merged back into develop, which may have progressed since the release was initiated.\nUsing a dedicated branch to prepare releases makes it possible for one team to polish the current release while another team continues working on features for the next release. It also creates well-defined phases of development.\nThe release version name must follow the Semantic versionning rules\ngit checkout develop git checkout -b release/0.1.0 Bugfix branch From : develop\nEach new bug should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen a bugfux is complete and tested, it gets merged back into develop. Bugfixes never interact directly with master.\ngit checkout develop git checkout -b fix/#456/export-button-color Hotfix branch From : master\nUsed to quickly patch production releases.\nThis is the only branch that should fork directly off of master. As soon as the fix is complete, it should be merged into both master and develop (or the current release branch), and master should be tagged with an updated version number.\nHaving a dedicated line of development for bug fixes lets your team address issues without interrupting the rest of the workflow or waiting for the next release cycle.\ngit checkout master git checkout -b fix/#344/wrong-email-regex Refactor branch From : develop\nUseful technical debt reduction, ESlint/SonarQube fix,\nEach refactor should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen refactor is complete and tested, it gets merged back into develop. Tests never interact directly with master.\ngit checkout develop git checkout -b feat/#426/export-csv-class Doc branch From : develop\nEach documentation update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nDoc branch is only for developer documentation in order to improve collabortation in the team. User documentation update has to be developed in a feature branch.\nWhen documentation is complete, it gets merged back into develop. Documentations never interact directly with master.\ngit checkout develop git checkout -b doc/#112/user-erd Test branch From : develop\nEach test update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen test is complete, it gets merged back into develop. Tests never interact directly with master.\ngit checkout develop git checkout -b test/#821/csv-export Build branch From : develop\nEach build update should reside in its own branch, which can be pushed to the central repository for backup and collaboration.\nWhen build is complete and tested, it gets merged back into develop. Builds never interact directly with master.\ngit checkout develop git checkout -b feat/#514/gitbranchvalidator "},{"id":3,"href":"/efficient-git/conventional-commit/","title":"Commits","parent":"Efficient Git","content":"This is a simplifed version of the original conventional commits.\nFollowing those rules to write your commit messages will bring great advantages to a project :\nAutomatic CHANGELOGs capability. Automatic semantic version bump (based on the types of commits landed). Readable nature of changes to teammates, the public, and other stakeholders. Automatic trigger of build and publish processes. Easier contribution to the project for new developers, by allowing them to explore a more structured commit history. The message is structured as follows:\n\u0026lt;type\u0026gt;(\u0026lt;scope\u0026gt;): [\u0026lt;#ticket\u0026gt;] \u0026lt;description\u0026gt; Types They are based on the Angular convention and must be one of the following:\nbuild: Changes that affect the build system or external dependencies (example scopes: gulp, broccoli, npm) ci: Changes to our CI configuration files and scripts (example scopes: Travis, Circle, BrowserStack, SauceLabs) doc: Documentation only changes feat: A new feature fix: A bug fix perf: A code change that improves performance refactor: A code change that neither fixes a bug nor adds a feature style: Changes that do not affect the meaning of the code (white-space, formatting, missing semi-colons, etc) test: Adding missing tests or correcting existing tests chore: Changes to the build process or auxiliary tools and libraries revert: Revert a previous commit. In this case it should begin with \u0026ldquo;revert:\u0026rdquo;, followed by the header of the reverted commit. In the body it should say: This reverts commit ., where the hash is the SHA of the commit being reverted. Scope The scope should be the name of the updated component.\n#ticket The id of the ticket or issue you are working on in this commit.\nDescription A succinct description of the change:\nUse the imperative, present tense: \u0026ldquo;change\u0026rdquo; not \u0026ldquo;changed\u0026rdquo; nor \u0026ldquo;changes\u0026rdquo; Don\u0026rsquo;t capitalize letters No dots (.) Additional Rules fix: Patches a bug in your codebase (this correlates with PATCH in semantic versioning). feat: Introduces a new feature to the codebase (this correlates with MINOR in semantic versioning, or MAJOR in case of a BTRAKING CHANGE). Additional types: are not mandated by the conventional commits specification, and have no implicit effect in semantic versioning (unless they include a BREAKING CHANGE). Breaking change: A commit that start with \u0026ldquo;BREAKING!\u0026rdquo; in the description introduces a breaking API change (correlating with MAJOR in semantic versioning). A BREAKING CHANGE can be part of commits of any type. Examples git commit -m \u0026#34;feat(lang): [#346] add polish language\u0026#34; git commit -m \u0026#34;feat(parser): [#546] add ability to parse arrays\u0026#34; git commit -m \u0026#39;feat(config): [neo-118] BREAKING! allow provided config object to extend other configs "},{"id":4,"href":"/efficient-git/","title":"Efficient Git","parent":"","content":" Use Git without hassle Understanding how to use Git will give a major boost to your daily work. A very useful tool indeed; And like every tool, it has been created mostly to make you gain time.\nBut if you and/or your team are not using it properly, Git can be a massive waste of time and money.\nThis guide will teach you how to Git efficiently. The simple and most useful way. In order to make Git as effortless as possible in your daily work and focus on development of applications.\nGetting Started "},{"id":5,"href":"/efficient-git/overview/","title":"Getting Started","parent":"Efficient Git","content":" Create a repo Let\u0026rsquo;s start manipulate Git by creating a Git repository.\nIn a new folder on your computer type :\ngit init This will create a hidden .git folder inside your current folder — this is the \u0026ldquo;repository\u0026rdquo; (or repo) where git stores all of its internal tracking data. Any changes you make to any files within the original folder will now be possible to track.\nThe original folder is now referred to as your working directory, as opposed to the repository (the .git folder) that tracks your changes. You work in the working directory. Simple!\nClone an existing repo git clone https://github.com/xxx/xxxx.git This will download a .git repository from the internet (GitHub) to your computer and extract the latest snapshot of the repo (all the files) to your working directory. By default it will all be saved in a folder with the same name as the repo.\nThe URL you specify here is called the remote origin (the place where the files were originally downloaded from). This term will be used later on.\nView the status of your project git status This will print some basic information, such as which files have recently been modified.\nYou should check your status anytime you’re confused. Git will print additional information depending on what’s currently going on in order to help you out.\nCreate a new branch git branch \u0026lt;new-branch-name\u0026gt; You can think of this like creating a local “checkpoint” (technically called a reference) and giving it a name. It’s similar to doing File \u0026gt; Save as… in a text editor; the new branch that gets created is a reference to the current state of your repo. The branch name can then be used in various other commands as you’ll soon see.\nCommits are also checkpoints called a revision. The name will be a random-looking hash of numbers and letters such as e093542. This hash can then be used in various other commands just like branch names.\nWhen working on a project, every time you start a new feature or bug fix, you create a new branch from develop, release or master/main. Depending on the work you have to do and the moment in the sprint.\nFor more info about creating branches please refer to Gitflow/branch.\nCheck out a branch git checkout \u0026lt;existing-branch-name\u0026gt; You can think of this like “resuming” from an existing checkpoint. All your files will be reset to whatever state they were in on that particular branch.\nKeep in mind that any changes in your working directory will be kept around. Preventing you to switch branche. See git stash if you’re interested in a simple way to avoid unwanted commits.\nYou can use the -b flag as a shortcut if you want to create the new branch while check it out all in one step. This is quite common:\ngit checkout -b \u0026lt;new-branch-name\u0026gt; View the differences between checkpoints:\ngit diff \u0026lt;branch-name\u0026gt; \u0026lt;other-branch-name\u0026gt; After editing some files, you can simply type git diff to view a list of the changes you’ve made. This is a good way to double-check your work before committing it.\nFor each group of changes, you’ll see what the file used to look like (prefixed with - and colored red), followed by what it looks like now (prefixed with + and colored green).\nSee further down for more advanced examples of this command.\nStage your changes git add \u0026lt;files\u0026gt; After editing some files, this command will mark any changes you’ve made as “staged” (or “ready to be committed”).\nIf you then go and make more changes, those new changes will not automatically be staged, even if you’ve changed the same files as before. This is useful for controlling exactly what you commit, but also a major source of confusion for newcomers.\nIf you’re ever unsure, just type git status again to see what’s going on. You’ll see “Changes to be committed:” followed by file names in green. Below that you’ll see “Changes not staged for commit:” followed by file names in red. These are not yet staged.\nAs a shortcut, you can use wildcards just like with any other terminal command. For example:\ngit add README.md app/*.txt This will add the file README.md, as well as every file in the app folder that ends in .txt.\nYou can also add everything that’s changed like this :\ngit add --all Commit your staged changes git commit -m \u0026#34;\u0026lt;conventional-commit-message\u0026gt;\u0026#34; This will open your default command-line text editor and ask you to type in a commit message. As soon as you save and quit, your commit will be saved locally.\nThe commit message is important to help other people understand what was changed and why you changed it. There’s a brief guide here explaining how to write useful commit messages.\nYou can use the -m flag as a shortcut to write a message. For example:\ngit commit -m “Add a new feature” Push your branch on the server git push This will upload your branch to the remote named origin (remember, that’s the URL defined initially during clone).\nAfter a successful push, your teammates will then be able to pull your branch to view your commits (see git pull below).\nFetch the latest info about a repo git fetch This will download the latest info about the repo from origin (such as all the different branches stored on GitHub).\nIt doesn’t change any of your local files — just updates the tracking data stored in the .git folder.\nMerge in changes from somebody else git merge \u0026lt;other-branch-name\u0026gt; This will take all commits that exist on the other-branch-name branch and integrate them into your own current branch.\nThis uses whatever branch data is stored locally, so make sure you’ve run git pull first to download the latest info.\nYou can use the pull command to both fetch and merge all in one step.\nFor a deeper understanding of how merging works and how conflicts are resolved see the merge docs.\n"},{"id":6,"href":"/efficient-git/submodule/","title":"Git Submodules","parent":"Efficient Git","content":"Git submodules are a powerful way to leverage git as an external dependency management tool. They allow a git repository to get other repositories as subdirectories. Git submodules are simply a reference to another repository at a particular snapshot in time. Git submodules enable a Git repository to incorporate and track version history of external code.\nWhen to use When working in a multi-repositories project When using the same libraries in several projects Workflow If you want to launch a project on your local environment, clone the parent project (ie. the one with all the submodules inside). This repository downloaded all the other ones. You can now work on the service tou want by clicking the subdirectory of the service. You can also launch the project on your local environment by reading the doncumentation in the parent repository.\nWhen working with submodules, a common pattern of confusion is forgetting to push updates for remote users. When you commit changes to a service in the parent repository, don\u0026rsquo;t forget to update the child repository as well.\n"},{"id":7,"href":"/efficient-git/gitflow/","title":"Gitflow overview","parent":"Efficient Git","content":"Gitflow is the most used Git branching model that involves the use of feature branches and multiple primary branches. Compared to trunk-based development, Giflow has numerous, longer-lived branches and larger commits. Under this model, developers create a feature branch and delay merging it to the main trunk branch until the feature is complete. These long-lived feature branches require more collaboration to merge and have a higher risk of deviating from the trunk branch. They can also introduce conflicting updates.\nGitflow can be used for projects that have a scheduled release cycle and for the DevOps best practice of continuous delivery. This workflow doesn’t add any new concepts or commands beyond what ahs been already discussed. In essence Gitflow assigns very specific roles to different branches and defines how and when they should interact. It uses individual branches for preparing, maintaining, and recording releases. Of course, you also get to leverage all the benefits of the Feature Branch Workflow: pull requests, isolated experiments, and more efficient collaboration.\nSummary The overall flow is as follow :\nA develop branch is created from master. A release branch is created from develop. Feature, Doc, Test and Build branches are created from develop. When a feature is complete it is merged into the develop branch. When the release branch is done it is merged into develop then master on release date. If an issue in master is detected a hotfix branch is created from master. Once the hotfix is complete it is merged to both master and develop. Here is a Gitflow chart to summarize the method :\n"},{"id":8,"href":"/efficient-git/gitlab/","title":"Gitlab","parent":"Efficient Git","content":""},{"id":9,"href":"/efficient-git/gitlab/organization/","title":"Organization","parent":"Gitlab","content":" Naming rules Simple rules to name groups, subgroups and repositories :\nLetters are in lowercase No whitespace. Use dash (-) instead No special characters Folders Overview Current folders :\n\u0026lt;entity\u0026gt;/project/: contains repositories for projects \u0026lt;entity\u0026gt;/doc/: contains repositories for documentations \u0026lt;entity\u0026gt;/template/: contains repositories to help architects, tech leads and devops to start a new project faster (ie: starter kits, configurations\u0026hellip;) \u0026lt;entity\u0026gt;/library/: contains repositories for reusable code over several projects. This code is bundled as independent libraries; published and installed via the package manager of the targeted language. The goal is to keep a readable folder structure for easy understanding and access.\nProjects Projects are applications.\nThe path for projects is of the form \u0026lt;entity\u0026gt;/project/\u0026lt;city\u0026gt;/\u0026lt;client\u0026gt;/\u0026lt;precision\u0026gt;/\u0026lt;application\u0026gt;\n\u0026lt;precision\u0026gt; folder could be duplicated if needed (ie: \u0026lt;precision1\u0026gt;/\u0026lt;precision2\u0026gt;\u0026hellip;). It is useful to give more details about the client. For example big companies with several entities. Add a \u0026lt;service\u0026gt; folder at the end in case of mutli-repos application Documentations Documentations are written in Markdown and built as a website with Hugo. The theme used is Hugo Geekdoc.\nThe path for documentations is of the form \u0026lt;entity\u0026gt;/doc/\u0026lt;topic\u0026gt;\nExample :\n\u0026lt;entity\u0026gt;/doc/git/ \u0026lt;entity\u0026gt;/doc/angular/ Templates Templates are reusable pieces of architectures that will help start a new project. For example it can be a starter kit for a given framework, configuration files for cloud computing, or a set of pre-developped services for a microservice architecture.\nThe path for templates is of the form \u0026lt;entity\u0026gt;/template/\u0026lt;family\u0026gt;/\u0026lt;framework\u0026gt;/\u0026lt;precision\u0026gt;\nPossible \u0026lt;family\u0026gt;/ folders could be : web for web applications desktop for desktop applications embedded for embedded applications \u0026lt;framework\u0026gt;/ folder should be used at the architectural level only. Like \u0026ldquo;micorservices/monolith\u0026rdquo; or \u0026ldquo;cloud/on-premise\u0026rdquo; (ie: not language based frameworks like Angular or React for Javascript). If no sub level of precision is required, \u0026lt;framework\u0026gt;/ will be a repository instead of a folder. \u0026lt;precision\u0026gt; folders is optional and may not be used if not applicable. It allows to add a specificity to the template in case you need two or more templates for the same framework in the future. For example several starter kits for the same monolith framework with important strategic differences. \u0026lt;precision\u0026gt; folder could be duplicated if more templates of the same parent folder are needed (ie: \u0026lt;precision1\u0026gt;/\u0026lt;precision2\u0026gt;\u0026hellip;). The last level of \u0026lt;precision\u0026gt; will be a repository instead of a folder. Example with a starter kit for Docker based microservices web application stored in a mono-repository:\n\u0026lt;entity\u0026gt;/template/web/microservices/mono-repo Note we did not mentioned Docker in the path as all our web application templates are based on it.\nLibraries Libraries are reusable independent code snippets that can be used and reused in several projects to perform common functions. They are written and maintained internally by the teams and bundled as independent libraries we can publish and install with the package manager of the targeted language.\nThe path for libraries is of the form \u0026lt;entity\u0026gt;/library/\u0026lt;language\u0026gt;/\u0026lt;framework\u0026gt;/\u0026lt;name\u0026gt;\n\u0026lt;framework\u0026gt; folder is optional and may not be used if not applicable. It is useful if the library is specific to a framework of the language. Like an Angular component. \u0026lt;name\u0026gt; repository is the name of the library "},{"id":10,"href":"/efficient-git/save/","title":"Save","parent":"Efficient Git","content":"Git is not meant to be used as a backup device.\nBut let\u0026rsquo;s be pragmatic here as not every company has a proper way of backing up developers work every day.\nAs said before the core function of Git is to save checkpoints. Thus, if used properly, Git is a poweful backup application for developers and can save you from losing several days of work in case of problem.\nOverview This backup routine should be done every evening when you leave work. And every morning when you start your day in order to recover your work as you left it the day before.\nNote that you only need to do this if your current work is sufficiently started since the last commit you have pushed and the current state is not mature enough for a proper intermediary conventional commit.\nIf you can commit properly just do it and push. This is the simplest way to backup your work.\nStep 1: Save your work You are leaving for the day and started to work on a new branch. Your job is not finished yet, nothing is working yet so an intermediate commit would not be right. It is then time to backup your work in case your computer does not start tomorrow morning.\nThis commands only work if it is the first time you are saving your work on this branch. If it is not the case please jump to step 3.\ngit status git add . git commit -m \u0026#34;WIP\u0026#34; git push Your work is safe now.\nStep 2: Retrieve your backup The day after you want to retrieve the same state as ealier. For this you have to reset your backup commit.\nIf your computer died during the night and is not starting up anymore, you can pull your save to another computer and work as if nothing happened. The backup saved you from starting from scratch again.\nHopefully, most of the time, you will not have any issue during the night. The next morning you then need to reset your commit on your local branch so you can keep seeing your modification in your IDE:\ngit reset HEAD~1 Now your backup commit is reset in the local repository. This also means your local branch diverged compared to the remote branch. Thus you want to get your remote banch up to date. To do so you need to pull the remote in order to revert it:\ngit stash git pull git revert HEAD git push git stash apply Now your \u0026ldquo;WIP\u0026rdquo; commit is reverted in the remote branch head but still exists in the remote as an older commit if needed.\nStep 3: Save your work again after a previous backup This is the end of the second day working on this feature. You want to backup again before leaving for the day.\nRepeat step 1.\nStep 4: Finish your work Once this feature is done. Commit following step 1 except for the commit message of course. Then create your merge request with the squash option checked because all these steps will create a commit for each backup.\n"},{"id":11,"href":"/efficient-git/semantic-versioning/","title":"Semantic Versioning","parent":"Efficient Git","content":"Semantic versioning is not exactly a Git topic. But since you will need to bump the version of the application after each release and tag the master branch, you need to learn how to properly update it following the Semantic versioning principles.\nOverview Given a version number MAJOR.MINOR.PATCH, increment the:\nMAJOR version when you make incompatible API changes, MINOR version when you add functionality in a backwards compatible manner, PATCH version when you make backwards compatible bug fixes. Additional labels for pre-release and build metadata are available as extensions to the MAJOR.MINOR.PATCH format.\nIntroduction The bigger a system grows and the more packages integrated into a software, the more we need a solid versioning process.\nIn systems with many dependencies, releasing new package versions needs to be carefully handled.\nTo prevent any version issue we use a global set of rules and requirements that dictate how version numbers are assigned and incremented.\nConsider a version format of X.Y.Z (Major.Minor.Patch).\nBug fixes not affecting the application increment the patch version Backwards compatible application additions/changes increment the minor version Backwards incompatible application changes increment the major version Under this scheme, version numbers and the way they change convey meaning about the underlying code and what has been modified from one version to the next.\nSemantic Versioning Specification (SemVer) A normal version number MUST take the form X.Y.Z where X, Y, and Z are non-negative integers, and MUST NOT contain leading zeroes.\nX is the major version Y is the minor version Z is the patch version. Each element MUST increase numerically. For instance: 1.9.0 -\u0026gt; 1.10.0 -\u0026gt; 1.11.0. Once a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\nHistory Major version zero (0.y.z) is for initial development. Anything MAY change at any time. The application SHOULD NOT be considered stable.\nVersion 1.0.0 defines the first release in production. The way in which the version number is incremented after this release is dependent on the application and how it changes.\nPatch version Z (x.y.Z | x \u0026gt; 0) MUST be incremented if only backwards compatible bug fixes are introduced. A bug fix is defined as an internal change that fixes incorrect behavior.\nMinor version Y (x.Y.z | x \u0026gt; 0) MUST be incremented if new, backwards compatible functionality is introduced to the application. It MUST be incremented if any application functionality is marked as deprecated. It MAY be incremented if substantial new functionality or improvements are introduced within the private code. It MAY include patch level changes. Patch version MUST be reset to 0 when minor version is incremented.\nMajor version X (X.y.z | X \u0026gt; 0) MUST be incremented if any backwards incompatible changes are introduced to the application. It MAY also include minor and patch level changes. Patch and minor version MUST be reset to 0 when major version is incremented.\nA pre-release version MAY be denoted by appending a hyphen and a series of dot separated identifiers immediately following the patch version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Numeric identifiers MUST NOT include leading zeroes. Pre-release versions have a lower precedence than the associated normal version. A pre-release version indicates that the version is unstable and might not satisfy the intended compatibility requirements as denoted by its associated normal version. Examples: 1.0.0-alpha, 1.0.0-alpha.1.\nBuild metadata MAY be denoted by appending a plus sign and a series of dot separated identifiers immediately following the patch or pre-release version. Identifiers MUST comprise only ASCII alphanumerics and hyphens [0-9A-Za-z-]. Identifiers MUST NOT be empty. Build metadata MUST be ignored when determining version precedence. Thus two versions that differ only in the build metadata, have the same precedence. Examples: 1.0.0-alpha+001, 1.0.0+20130313144700, 1.0.0-beta+exp.sha.5114f85, 1.0.0+21AF26D3—-117B344092BD.\nprecedence Precedence refers to how versions are compared to each other when ordered.\nIt MUST be calculated by separating the version into major, minor, patch and pre-release identifiers in that order (Build metadata does not figure into precedence).\nIt is determined by the first difference when comparing each of these identifiers from left to right as follows: Major, minor, and patch versions are always compared numerically.\nExample: 1.0.0 \u0026lt; 2.0.0 \u0026lt; 2.1.0 \u0026lt; 2.1.1.\nWhen major, minor, and patch are equal, a pre-release version has lower precedence than a normal version:\nExample: 1.0.0-alpha \u0026lt; 1.0.0\nPrecedence for two pre-release versions with the same major, minor, and patch version MUST be determined by comparing each dot separated identifier from left to right until a difference is found as follows:\nIdentifiers consisting of only digits are compared numerically.\nIdentifiers with letters or hyphens are compared lexically in ASCII sort order.\nNumeric identifiers always have lower precedence than non-numeric identifiers.\nA larger set of pre-release fields has a higher precedence than a smaller set, if all of the preceding identifiers are equal.\nExample: 1.0.0-alpha \u0026lt; 1.0.0-alpha.1 \u0026lt; 1.0.0-alpha.beta \u0026lt; 1.0.0-beta \u0026lt; 1.0.0-beta.2 \u0026lt; 1.0.0-beta.11 \u0026lt; 1.0.0-rc.1 \u0026lt; 1.0.0.\nInitial phase Start your initial development release at 0.1.0 and then increment the minor version for each subsequent release.\nWhen to release 1.0.0 If your software is being used in production, it should probably already be 1.0.0. If you have a stable application on which users have come to depend, you should be 1.0.0. If you’re worrying a lot about backwards compatibility, you should probably already be 1.0.0. If you’re changing the application every day you should either still be in version 0.y.z or on a separate development branch working on the next major version.\nBump to a major version. This is a question of responsible development and foresight. Incompatible changes should not be introduced lightly to software that has a lot of dependent code. The cost that must be incurred to upgrade can be significant. Having to bump major versions to release incompatible changes means you’ll think through the impact of your changes, and evaluate the cost/benefit ratio involved.\nReleasing a backwards incompatibility by mistake As soon as you realize that you’ve broken the Semantic Versioning spec, fix the problem and release a new minor version that corrects the problem and restores backwards compatibility. Even under this circumstance, it is unacceptable to modify versioned releases. If it’s appropriate, document the offending version and inform your users of the problem so that they are aware of the offending version.\nUpdating application dependencies without changing the application That would be considered compatible since it does not affect the application. Software that explicitly depends on the same dependencies as your package should have their own dependency specifications and the author will notice any conflicts. Determining whether the change is a patch level or minor level modification depends on whether you updated your dependencies in order to fix a bug or introduce new functionality. In which case it’s a minor level increment.\nAltering the aplication (i.e. the code incorrectly introduces a major breaking change in a patch release)\nUse your best judgment. If you have a huge audience that will be drastically impacted by changing the behavior back to what the public API intended, then it may be best to perform a major version release, even though the fix could strictly be considered a patch release. Remember, Semantic Versioning is all about conveying meaning by how the version number changes. If these changes are important to your users, use the version number to inform them.\nHandling deprecating functionality Deprecating existing functionality is a normal part of software development and is often required to make forward progress. When you deprecate part of your public API, you should do two things: (1) update your documentation to let users know about the change, (2) issue a new minor release with the deprecation in place. Before you completely remove the functionality in a new major release there should be at least one minor release that contains the deprecation so that users can smoothly transition to the new API.\nSize limit on the version string Use good judgment. A 255 character version string is overkill and unreadable.\nUsing v “v1.2.3” is not a semantic version. However, prefixing a semantic version with a “v” is a common way (in English) to indicate it is a version number. Abbreviating “version” as “v” is often seen with version control. Example: git tag v1.2.3 -m \u0026ldquo;Release version 1.2.3\u0026rdquo;, in which case “v1.2.3” is a tag name and the semantic version is “1.2.3”.\n"},{"id":12,"href":"/efficient-git/squash/","title":"Squash","parent":"Efficient Git","content":" What is Git Squash Squashing in Git is the process of merging several commits into one.\nWhy would I want to squash my commits Often when we are working on a feature / bug fix / refactor etc, we may find ourselves making several interim commits over the duration of the change. Whilst we can push back to our main branch including all of these commits, this creates noise in the commit history potentially making it harder to identify the actual commit we are interested in.\nHow do I Squash my commits Git does not have a specific command to squash commits instead we make use of existing git commands.\ngit merge \u0026ndash;squash \u0026ldquo;git merge \u0026ndash;squash\u0026rdquo; allows us to merge one branch into another whilst condensing the commit history on the branch we are merging. It does this by creating a new commit and adding our changes to this commit, but stops before making the actual commit leaving us to add the clean commit message.\nThe following example assumes you have the ability to merge into develop and push this change back to the develop branch. In practice and on many projects pushing directly to any of the \u0026ldquo;main\u0026rdquo; application branches will be blocked and in these cases the merge squash feature should be used in tools like github and gitlab. You can read more about squashing using Github or Gitlab.\nIn the following example we have been given the task to create a \u0026ldquo;fab-feature\u0026rdquo; and so the first thing we might do is create our new branch assuming we already have pulled recent changes from the main repo.\ngit checkout -b feature/fab-feature on checking the log we might see something like this\ngit log commit 2ff6bd (HEAD -\u0026gt; /fab-feature) feature/fab-feature commit 905F7D feature/great-feature commit 0DE673 (origin/develop) intial commit We would then start work on Fab-feature, at some point we will have completed the work and are ready to merge back to our main branch in this case \u0026ldquo;develop\u0026rdquo;, however during the development we made several interim commits.\nTo keep the develop branch clean we want to get rid of the commit history and register a single commit comment which makes it clear for other people what this commit related to.\nOur commit history on our fab-feature branch might look something like this.\ngit log commit 5ef6bd (HEAD -\u0026gt; feature/fab-feature) implemented fab feature commit c675F7D adding tests for fab feature commit 98DE673 working on fab feature commit 65EF5F started work on fab feature To squash these commits we first need to checkout the branch we want to merge into, in this case the \u0026ldquo;develop\u0026rdquo; branch\ngit checkout develop to merge our changes from the feature/fab-feature branch and squash the commit history we use\ngit merge feature/fab-feature --squash This should merge our feature branch back into develop and squash our commit history.\nAt this stage it is important to note git has not committed this merge for us, we must do this by adding a final commit message that we want to remain in develop branch history. This message should represent the feature we have just worked on:\ngit commit -m \u0026#34;feature/fab-feature\u0026#34; at the end of this process our log would look like this:\ngit log commit 2ff6bd (HEAD -\u0026gt; develop) feature/fab-feature commit 905F7D feature/great-feature commit 0DE673 (origin/develop) intial commit Note our feature branch will still retain the git history for that branch until we delete the branch.\n"},{"id":13,"href":"/efficient-git/tag/","title":"tag","parent":"Efficient Git","content":"Git has the ability to tag specific points in a repository’s history. Within the Gitflow process, it is used to mark release points (v1.0, v2.0 and so on) on main branch.\nListing Your Tags git tag This command lists the tags in alphabetical order; the order in which they are displayed has no real importance.\nYou can also search for tags that match a particular pattern. The Git source repo, for instance, contains more than 500 tags. If you’re interested only in looking at the 1.8.5 series, you can run this:\ngit tag -l \u0026#34;v1.8.5*\u0026#34; Release a new version of master In the Gitflow process you want to tag master/main branch anytime you merge something into it.\nSo when release branch or a hotfix branch is merged into master, tagging master should be part of the process.\nYou can read the Semantic versioning page to learn more about how to tag the branch properly using the version number.\nOnce a versioned package has been released, the contents of that version MUST NOT be modified. Any modifications MUST be released as a new version.\nCreate annotated Tags You use Github or Gitlab graphics interface to create a tag.\nAnnotated tags are stored as full objects in the Git database. They’re checksummed; contain the tagger name, email, and date; have a tagging message; and can be signed and verified with GNU Privacy Guard (GPG).\ngit tag -a v1.4 -m \u0026#34;my version 1.4 is cool\u0026#34; You can see the tag data along with the commit that was tagged by using the git show command:\ngit show v1.4 Checking out If you want to view the versions of files a tag is pointing to, you can do a git checkout of that tag, although this puts your repository in “detached HEAD” state, so do not make any changes on this state.\ngit checkout v2.0.0 "},{"id":14,"href":"/efficient-git/tags/","title":"Tags","parent":"Efficient Git","content":""},{"id":15,"href":"/efficient-git/teamwork/","title":"Teamwork","parent":"Efficient Git","content":" Commit your work Description A commit contains the current contents of the index and the given log message describing the changes.\nThe new commit is a direct child of HEAD, usually the tip of the current branch, and the branch is updated to point to it (unless no branch is associated with the working tree, in which case HEAD is \u0026ldquo;detached\u0026rdquo;).\nWhen When you finish a sub task. it is a good practice to commit several time in a day. every time it feels logicial to you. It helps keeping commits short, easy to understand and easy for you to describe in a commit message. It also helps create several checkpoints so in case of issue you have several moment you can go back to or read.\nThe commit message is important to help other people understand what was changed and why you changed it. There’s a brief guide here explaining how to write useful commit messages.\nHow Usually you want to commit all your changes. If not you can add only the files you want to using \u0026ldquo;git add \u0026rdquo;. After your commit is done you can push it on the remote branch :\ngit status git add . git commit -m \u0026#34;\u0026lt;conventional-commit-message\u0026gt;\u0026#34; git push Submit your changes After working on a new feature for the team you have your changes ready and tested on a branch. It is time to get them back onto the trunk as part of the “official” codebase.\nOnce you’ve tested your changes, you’ll do this via a pull request (PR) or a merge request (MR) — they’re the same thing, the term just depends on what software you’re using (e.g. GitHub/Bitbucket/GitLab). You’re requesting that your changes be pulled in and merged.\nA merge request is done via the application used in the project : Github or Gitlab\nYour team will be happy to receive new PRs, even if the code needs a bit of work before being accepted. PRs are an important part of the open-source ecosystem.\nThe main thing to remember is to include a clear explanation of why you’re making the changes in order to give context.\nDiscussing and revising Once you submit your PR, someone else on the team will need to look it over and leave feedback. They can ask questions and comment on specific lines of code, or they can give more general feedback about your changes. In some cases they may push their own changes directly to your branch, but usually they’ll ask you to make the changes yourself.\nIf you want to make changes based on the feedback, simply add more commits to your existing branch and push it to origin again. The PR will update automatically to reflect your changes.\nStay up to date If some time goes by before your PR is accepted, it might get “stale”, meaning it’s based on an older version of the trunk. Your changes may have worked a week ago, but there’s no guarantee that they still work alongside other, more recent changes to the trunk.\nTo get up to date, you can “merge in” the changes using git merge develop/release. This will apply any new changes from the trunk on top of your work.\nYou are effectively just moving your branch up to the top of the trunk to stay up to date with the latest code.\nSome people may prefer \u0026ldquo;rebase\u0026rdquo; method; it is safer and easier to merge.\nDeal with conflicts When merging, you will occasionally run into conflicts. This means you changed a line of code that someone else also changed, and git doesn’t know which version to keep.\nNote that this is a normal behaviour and you should not be afraid or annoyed by conflict. Fix them safely, and ask for help if you have doubts.\nWhen conflicts happens the output from git has weird \u0026raquo;\u0026raquo;\u0026raquo;\u0026gt; ======= \u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; symbols.\nIn essence, you just need to remove those weird symbols and manually combine the code in between them.\nFor example, the line:\nprint \u0026ldquo;Hello\u0026rdquo; Might be changed on two separate branches, leading to the conflict:\n\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; print \u0026#34;Hello, world\u0026#34; ======= print \u0026#34;Hello!\u0026#34; \u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt;\u0026lt; Which, when resolved, might become:\nprint \u0026#34;Hello, world!\u0026#34; After manually merging the conflicting lines together — keeping both the “world” and the “!”, which had each been added separately.\nAccepting your changes Once all of the PR comments have been addressed and any conflicts have been resolved, your branch is ready to be merged!\nAn administrator of the codebase can accept the PR by merging your branch into the trunk — simply by pressing a button on GitHub/Gitliab — thus making your changes official.\nSquash merge Squash merging is a merge option that allows you to condense the Git history of topic branches when you complete a pull request. Instead of each commit on the topic branch being added to the history of the default branch, a squash merge adds all the file changes to a single new commit on the default branch.\nWhen you merge using Gitlab or Github there is a checkbox to squash all the commits into one. It is highly recommanded to use it in order to keep a clean history on the default branch.\nA simple way to think about this is that squash merge gives you just the file changes, and a regular merge gives you the file changes and the commit history.\nWhen squash merging, it\u0026rsquo;s a good practice to delete the source branch. Deleting the source branch prevents confusion as the topic branch itself doesn\u0026rsquo;t have a commit merging it into the default branch.\n"},{"id":16,"href":"/efficient-git/intro/","title":"What is Git","parent":"Efficient Git","content":"Git is the most popular Version Control System.\nIt makes it easier to track changes to files in a project.\nYou can determine exactly what changed, who changed it, and why.\nThe core function of git is to save checkpoints (revisions) and share them with other people. Everything revolves around this concept. If you’ve ever created a checkpoint to something, you’ll be able to get back to it later as long as your .git folder is intact.\nSo everything in git can be thought of as a checkpoint. Here’s a list of the types of checkpoint :\nHEAD \u0026lt;branch-name\u0026gt;, e.g. master \u0026lt;commit-hash\u0026gt;, e.g. e093542d01d11c917c316bfaffd6c4e5633aba58 (or e093542 for short) \u0026lt;tag-name\u0026gt;, e.g. v1.0.0 It is mandatory for coordinating work among multiple people on a project, and for tracking progress over time by saving “checkpoints”.\nStarting from the trunk Git uses a lot of “tree” analogies. You can think of your main codebase as the trunk of a tree.\nEvery time you add more changes (aka commits), your tree grows taller, straight up. Even if you delete code, that’s still considered a change and causes the tree to grow. It’s like how the “undo” history in a text editor saves your keystrokes, including backspace.\nGit, by default, calls the trunk main or master. You can call it whatever you want; there’s nothing special about these words other than that it’s conventional.\nYou can travel up and down the trunk — equivalent to going forward and backward in time — by checking out specific “checkpoints” as described in the overview.\nBranching out Most projects have a backlog of new features to add and bugs to fix. When you want to address one of these issues, one way would be to grow the tree taller and commit directly to the trunk (master). This works fine for small projects or projects where you’re the only person making changes, but what if multiple people are working at the same time? It’s too easy to get in each other’s way and end up with conflicting changes.\nThe solution is branching. Instead of committing to the trunk, you create your own personal branch (e.g. my-cool-feature instead of master) and work from there. Now you’re growing your branch taller instead of the trunk.\nLet\u0026rsquo;s say your branch started at commit T2 from \u0026ldquo;develop\u0026rdquo;. While you were working on your branch (commits B1 and B2), someone else worked directly on develop (commits T3 and T4). Those commits aren’t in your branch yet; your branch is out of date.\nYou can also see real life branch visualizations on GitHub, or by typing :\ngit log --all --decorate --oneline --graph "}]